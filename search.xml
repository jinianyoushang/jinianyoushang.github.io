<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vscode通过ssh连接远程服务器+免密登录</title>
      <link href="/posts/57e2079d/"/>
      <url>/posts/57e2079d/</url>
      
        <content type="html"><![CDATA[<h3 id="vscode连接远程服务器"><a href="#vscode连接远程服务器" class="headerlink" title="vscode连接远程服务器"></a>vscode连接远程服务器</h3><p>1.在vscode下载Remote Development</p><p>2.点击远程<a href="https://so.csdn.net/so/search?q=资源管理器&amp;spm=1001.2101.3001.7020">资源管理器</a>选项卡，并选择远程(隧道/SSH)类别</p><p><img src="127a5fb100694767804c3ef3bd8670f5.png" alt="127a5fb100694767804c3ef3bd8670f5"></p><p>3.点击ssh配置</p><p><img src="f0f78a0f6a02449eac89cd32cdda813c.png" alt="f0f78a0f6a02449eac89cd32cdda813c"></p><p>4.在弹出的选择配置文件中，点击第一个</p><p>5.在config文件中输入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host &lt;显示的服务器名字&gt;</span><br><span class="line">    HostName &lt;服务器的ip&gt;</span><br><span class="line">    Port 22</span><br><span class="line">    User &lt;ssh登录的用户名&gt;</span><br></pre></td></tr></table></figure><p>如下</p><p><img src="5434bf95a1b0482abfbc0ca529be0cd1.png" alt="5434bf95a1b0482abfbc0ca529be0cd1"></p><p> 6.这时展开SSH，就能看到刚刚创建的配置了</p><p><img src="47c82cee61004113be8b74f2be47589a.png" alt="47c82cee61004113be8b74f2be47589a"></p><p>点击连接，输入密码即可。</p><h3 id="ssh使用密钥连接"><a href="#ssh使用密钥连接" class="headerlink" title="ssh使用密钥连接"></a>ssh使用密钥连接</h3><ol><li><p><strong>本地生成SSH密钥对</strong>：如果你还没有SSH密钥对，可以使用<code>ssh-keygen</code>命令在本地生成一对密钥（公钥和私钥）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></li><li><p><strong>复制公钥</strong>：使用<code>cat</code>命令或文本编辑器打开你的公钥文件（通常是<code>~/.ssh/id_rsa.pub</code>），并将公钥内容复制到剪贴板中。</p></li><li><p><strong>连接到Linux服务器</strong>：使用SSH连接到你的Linux服务器，可以使用以下命令：<code>--</code></p></li><li><p><strong>创建.ssh文件夹（如果不存在）</strong>：如果服务器上的<code>.ssh</code>文件夹不存在，你可以使用以下命令创建它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.ssh</span><br></pre></td></tr></table></figure></li><li><p><strong>将公钥添加到authorized_keys文件</strong>：将你的公钥粘贴到服务器上的<code>authorized_keys</code>文件中。你可以使用文本编辑器将公钥添加到文件中，或者使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;your_public_key&quot; &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li><li><p><strong>设置权限</strong>：确保<code>authorized_keys</code>文件的权限正确设置为<code>600</code>，这样只有拥有者才能读写该文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/savet/article/details/131683156">vscode通过ssh连接远程服务器+免密登录（图文）_vscode ssh-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> ssh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> 远程 </tag>
            
            <tag> vscode远程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++在ubuntu交叉编译</title>
      <link href="/posts/d50850af/"/>
      <url>/posts/d50850af/</url>
      
        <content type="html"><![CDATA[<h2 id="ubuntu中交叉编译"><a href="#ubuntu中交叉编译" class="headerlink" title="ubuntu中交叉编译"></a>ubuntu中交叉编译</h2><h3 id="1-安装交叉编译工具链64位"><a href="#1-安装交叉编译工具链64位" class="headerlink" title="1.安装交叉编译工具链64位"></a>1.安装交叉编译工具链64位</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu</span><br></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc --version</span><br><span class="line"></span><br><span class="line">#aarch64-linux-gnu-gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0</span><br><span class="line">#Copyright (C) 2021 Free Software Foundation, Inc.</span><br><span class="line">#This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">#warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE</span><br></pre></td></tr></table></figure><p>此时交叉编译工具链gcc在<code>/usr/bin/aarch64-linux-gnu-gcc</code>,g++在<code>/usr/bin/aarch64-linux-gnu-g++</code></p><p>头文件和库在<code>/usr/aarch64-linux-gnu</code>下</p><h3 id="2-测试"><a href="#2-测试" class="headerlink" title="2.测试"></a>2.测试</h3><p>写入main.cpp文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello!this is haiyue embreded world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-gnu-g++ main.cpp -o main</span><br></pre></td></tr></table></figure><p>查看相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file main</span><br></pre></td></tr></table></figure><p><code>main: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=bef44d88a3fff0790aadba3fa7c98ee937915af8, for GNU/Linux 3.7.0, not stripped</code></p><h3 id="3-使用cmake"><a href="#3-使用cmake" class="headerlink" title="3.使用cmake"></a>3.使用cmake</h3><p>先写一个简单的项目</p><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello!this is haiyue embreded world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span> main.cpp)</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build/test</span><br></pre></td></tr></table></figure><p><code>hello!this is haiyue embreded world!</code></p><p>说明项目可以运行。</p><h3 id="4-cmake配置交叉编译"><a href="#4-cmake配置交叉编译" class="headerlink" title="4.cmake配置交叉编译"></a>4.cmake配置交叉编译</h3><h4 id="方式1（不推荐）-直接在CMakeLists-txt指定"><a href="#方式1（不推荐）-直接在CMakeLists-txt指定" class="headerlink" title="方式1（不推荐）-直接在CMakeLists.txt指定"></a>方式1（不推荐）-直接在CMakeLists.txt指定</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接在CMakeLists.txt指定</span></span><br><span class="line"><span class="keyword">set</span>(tools /usr/bin)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_C_COMPILER <span class="variable">$&#123;tools&#125;</span>/aarch64-linux-gnu-gcc)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_COMPILER <span class="variable">$&#123;tools&#125;</span>/aarch64-linux-gnu-g++)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_ROOT_PATH /usr/aarch64-linux-gnu)  <span class="comment">#可选</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(<span class="keyword">test</span> main.cpp)</span><br></pre></td></tr></table></figure><h4 id="方式2（推荐）-通过-CMAKE-TOOLCHAIN-FILE指定"><a href="#方式2（推荐）-通过-CMAKE-TOOLCHAIN-FILE指定" class="headerlink" title="方式2（推荐）-通过 CMAKE_TOOLCHAIN_FILE指定"></a>方式2（推荐）-通过 CMAKE_TOOLCHAIN_FILE指定</h4><p>新建文件<code>aarch64-linux-gnu.cmake</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#aarch64-linux-gnu.cmake</span></span><br><span class="line"><span class="keyword">SET</span>(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_PROCESSOR arm)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_SYSTEM_VERSION <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译时 linux编译时候加上参数   -D CMAKE_TOOLCHAIN_FILE=aarch64-linux-gnu.cmake </span></span><br><span class="line"><span class="keyword">set</span>(tools /usr/bin)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_C_COMPILER <span class="variable">$&#123;tools&#125;</span>/aarch64-linux-gnu-gcc)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_CXX_COMPILER <span class="variable">$&#123;tools&#125;</span>/aarch64-linux-gnu-g++)</span><br><span class="line"><span class="keyword">SET</span>(CMAKE_FIND_ROOT_PATH /usr/aarch64-linux-gnu)</span><br></pre></td></tr></table></figure><p>编译指定工具链文件<code>-DCMAKE_TOOLCHAIN_FILE=aarch64-linux-gnu.cmake</code>即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -S . -B build2 -DCMAKE_TOOLCHAIN_FILE=aarch64-linux-gnu.cmake </span><br><span class="line">cmake --build build2</span><br></pre></td></tr></table></figure><h2 id="Windows中交叉编译"><a href="#Windows中交叉编译" class="headerlink" title="Windows中交叉编译"></a>Windows中交叉编译</h2><p>在windows中类似，需要下载好对应的交叉编译工具</p><p>并新建一个<code>aarch64-linux-gnu.cmake</code>文件，在其中指定好对应的编译器地址</p><p>在构建时指定对应的CMAKE_TOOLCHAIN_FILE，即可</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 交叉编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++工程：总结 CMake 添加第三方库依赖方式git submodule、 find_library、FetchContent、CPM等</title>
      <link href="/posts/e7a5d141/"/>
      <url>/posts/e7a5d141/</url>
      
        <content type="html"><![CDATA[<h1 id="C-工程：总结-CMake-添加第三方库依赖方式git-submodule、-find-library、FetchContent、CPM等"><a href="#C-工程：总结-CMake-添加第三方库依赖方式git-submodule、-find-library、FetchContent、CPM等" class="headerlink" title="C++工程：总结 CMake 添加第三方库依赖方式git submodule、 find_library、FetchContent、CPM等"></a>C++工程：总结 CMake 添加第三方库依赖方式git submodule、 find_library、FetchContent、CPM等</h1><p><strong>个人认为第2种，第6种，第7种比较好。</strong></p><p>CMake 已经成为了C++工程管理的主流方式，功能非常强大，现在大多数的 C++ 库都已经支持CMake，下面以 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fopen-source-parsers%2Fjsoncpp">jsoncpp</a> 为例，介绍几种引入第三方库的方式。</p><h2 id="1-代码依赖"><a href="#1-代码依赖" class="headerlink" title="1. 代码依赖"></a>1. 代码依赖</h2><p>这种方式是把第三方库的完整代码直接添加到我们的项目中，当做项目代码的一部分进行编译，这种方式会把第三方代码和我们的代码混在一起，并不推荐使用。首先我们需要到 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fopen-source-parsers%2Fjsoncpp">jsoncpp</a> 下载需要的头文件和实现代码，放到项目当中。</p><h5 id="工程文件目录"><a href="#工程文件目录" class="headerlink" title="工程文件目录"></a>工程文件目录</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">├── jsoncpp</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── json</span><br><span class="line">│   │       ├── autolink<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── config<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── features<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── forwards<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── json<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── reader<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── value<span class="selector-class">.h</span></span><br><span class="line">│   │       └── writer<span class="selector-class">.h</span></span><br><span class="line">│   ├── json_batchallocator<span class="selector-class">.h</span></span><br><span class="line">│   ├── json_internalarray<span class="selector-class">.inl</span></span><br><span class="line">│   ├── json_internalmap<span class="selector-class">.inl</span></span><br><span class="line">│   ├── json_reader<span class="selector-class">.cpp</span></span><br><span class="line">│   ├── json_value<span class="selector-class">.cpp</span></span><br><span class="line">│   ├── json_valueiterator<span class="selector-class">.inl</span></span><br><span class="line">│   └── json_writer<span class="selector-class">.cpp</span></span><br><span class="line">└── <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><h5 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.17)</span><br><span class="line">project(includes_full_code)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD 14)</span><br><span class="line"><span class="comment"># 包含头文件</span></span><br><span class="line">include_directories(./jsoncpp/include)</span><br><span class="line"><span class="built_in">set</span>(jsoncpp jsoncpp/json_reader.cpp jsoncpp/json_writer.cpp jsoncpp/json_value.cpp)</span><br><span class="line"><span class="comment"># 添加可执行代码</span></span><br><span class="line">add_executable(includes_full_code main.cpp <span class="variable">$&#123;jsoncpp&#125;</span>)</span><br></pre></td></tr></table></figure><h5 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h5><p>后面的示例的main.cpp都是一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;json/json.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Json::Value json;</span><br><span class="line">    json[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Wiki&quot;</span>;</span><br><span class="line">    json[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span>;</span><br><span class="line">    std::cout &lt;&lt; json.<span class="built_in">toStyledString</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftaoweiji%2Fcpp-cmake-example%2Ftree%2Fmaster%2Fincludes_full_code">includes_full_code_exmaple</a></p><h2 id="2-内部工程依赖"><a href="#2-内部工程依赖" class="headerlink" title="2. 内部工程依赖"></a>2. 内部工程依赖</h2><p>这种方式和上面 <code>代码依赖</code> 的方式类似，不同的是内部工程依赖会把第三方库的管理职责交给第三方库工程CMakeLists.txt文件，这种方式的好处是职责分明，是最常用的依赖方式。</p><h5 id="工程文件目录-1"><a href="#工程文件目录-1" class="headerlink" title="工程文件目录"></a>工程文件目录</h5><p>目录结果和上面的案例相似，不同的是jsoncpp文件夹多了一个 <code>CMakeLists.txt</code> 文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── jsoncpp</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── <span class="keyword">include</span></span><br><span class="line">│   │   └── json</span><br><span class="line">│   │       ├── autolink.h</span><br><span class="line">│   │       ├── config.h</span><br><span class="line">│   │       ├── features.h</span><br><span class="line">│   │       ├── forwards.h</span><br><span class="line">│   │       ├── json.h</span><br><span class="line">│   │       ├── reader.h</span><br><span class="line">│   │       ├── value.h</span><br><span class="line">│   │       └── writer.h</span><br><span class="line">│   ├── json_batchallocator.h</span><br><span class="line">│   ├── json_internalarray.inl</span><br><span class="line">│   ├── json_internalmap.inl</span><br><span class="line">│   ├── json_reader.cpp</span><br><span class="line">│   ├── json_value.cpp</span><br><span class="line">│   ├── json_valueiterator.inl</span><br><span class="line">│   └── json_writer.cpp</span><br><span class="line">└── main.cpp</span><br></pre></td></tr></table></figure><h5 id="jsoncpp-CMakeLists-txt"><a href="#jsoncpp-CMakeLists-txt" class="headerlink" title="jsoncpp/CMakeLists.txt"></a>jsoncpp/CMakeLists.txt</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.17)</span><br><span class="line">project(jsoncpp)</span><br><span class="line">add_library(<span class="variable">$&#123;PROJECT_NAME&#125;</span> json_reader.cpp json_value.cpp json_writer.cpp)</span><br><span class="line">target_include_directories(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/include)</span><br></pre></td></tr></table></figure><h5 id="CMakeLists-txt-1"><a href="#CMakeLists-txt-1" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.17)</span><br><span class="line">project(multi_cmakelists)</span><br><span class="line"><span class="comment"># 添加子工程</span></span><br><span class="line">add_subdirectory(jsoncpp)</span><br><span class="line">add_executable($&#123;PROJECT_NAME&#125; main.cpp)</span><br><span class="line"><span class="comment"># 链接子工程</span></span><br><span class="line">target_link_libraries($&#123;PROJECT_NAME&#125; jsoncpp)</span><br></pre></td></tr></table></figure><p>完整代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftaoweiji%2Fcpp-cmake-example%2Ftree%2Fmaster%2Fmulti_cmakelists">multi_cmakelists_example</a></p><blockquote><p>这种方式除了引入第三方依赖，通常我们也会用这种方式来管理项目中的各个子模块，每个模块都有独立的CMakeLists.txt文件，从而实现子工程的单独引用，源码请看 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftaoweiji%2Fcpp-cmake-example%2Ftree%2Fmaster%2Fsubdirectory">subdirectory_example</a>。</p></blockquote><h2 id="3-find-library：编译库方式引入"><a href="#3-find-library：编译库方式引入" class="headerlink" title="3. find_library：编译库方式引入"></a>3. find_library：编译库方式引入</h2><p>这种方式是用来依赖已经打包好的二进制文件，这种方式也分为静态库（.a、.lib）和动态库（.so、.dll）方式引入，这种方式也可以查找本机已经安装好的库，比如 Android 的 log 库就是通过这种方式引入。</p><h5 id="生成-a文件"><a href="#生成-a文件" class="headerlink" title="生成.a文件"></a>生成.a文件</h5><p>运行上面的 <code>内部工程依赖</code> 案例后，我们我们可以从项目中找到编译好的 multi_cmakelists/cmake-build-debug/jsoncpp/libjsoncpp.a 文件。</p><h5 id="工程文件目录-2"><a href="#工程文件目录-2" class="headerlink" title="工程文件目录"></a>工程文件目录</h5><p>和上面不同的是，这里只需要导入jsoncpp的头文件和.a文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">├── jsoncpp</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── json</span><br><span class="line">│   │       ├── autolink<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── config<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── features<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── forwards<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── json<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── reader<span class="selector-class">.h</span></span><br><span class="line">│   │       ├── value<span class="selector-class">.h</span></span><br><span class="line">│   │       └── writer<span class="selector-class">.h</span></span><br><span class="line">│   └── libjsoncpp<span class="selector-class">.a</span></span><br><span class="line">└── <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><h5 id="CMakeLists-txt-2"><a href="#CMakeLists-txt-2" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.17)</span><br><span class="line">project(find_library_example)</span><br><span class="line">include_directories(jsoncpp/include)</span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line">find_library(jsoncpp_lib NAMES jsoncpp PATHS ./jsoncpp)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;jsoncpp_lib&#125;</span>)</span><br></pre></td></tr></table></figure><p>完整代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftaoweiji%2Fcpp-cmake-example%2Ftree%2Fmaster%2Ffind_library">find_library_example</a></p><blockquote><p>这种方式在 Android 开发很常见，比如我们引入xlog实现日志打印就可以通过这种方式实现，代码参考 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftaoweiji%2Fcpp-cmake-example%2Ftree%2Fmaster%2Fxlog">xlog_example</a>。</p></blockquote><h2 id="4-FetchContent"><a href="#4-FetchContent" class="headerlink" title="4. FetchContent"></a>4. FetchContent</h2><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcmake.org%2Fcmake%2Fhelp%2Flatest%2Fmodule%2FFetchContent.html">FetchContent</a> 是 cmake 3.11.0 版本开始提供的功能，可以非常方便用来添加第三方依赖。</p><h5 id="工程文件目录-3"><a href="#工程文件目录-3" class="headerlink" title="工程文件目录"></a>工程文件目录</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">└── <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><h5 id="CMakeLists-txt-3"><a href="#CMakeLists-txt-3" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.17)</span><br><span class="line">project(fetch_content_example)</span><br><span class="line">include(FetchContent)</span><br><span class="line"><span class="comment">#FetchContent_Declare(jsoncpp</span></span><br><span class="line"><span class="comment">#        GIT_REPOSITORY https://github.com/open-source-parsers/jsoncpp.git</span></span><br><span class="line"><span class="comment">#        GIT_TAG 1.9.4)</span></span><br><span class="line"><span class="comment"># 建议使用压缩包的方式依赖，下载速度更快</span></span><br><span class="line">FetchContent_Declare(jsoncpp</span><br><span class="line">        URL https://github.com/open-source-parsers/jsoncpp/archive/1.9.4.tar.gz)</span><br><span class="line">FetchContent_MakeAvailable(jsoncpp)</span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> jsoncpp_lib)</span><br></pre></td></tr></table></figure><p>建议通过压缩包的方式引入，因为直接引入git仓库可能会很慢。</p><p>完整代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftaoweiji%2Fcpp-cmake-example%2Ftree%2Fmaster%2Ffetch_content">fetch_content_example</a></p><blockquote><p>Android SDK 的 CMake 的默认版本是3.10.2，并不支持FetchContent，如果想在Android开发中使用需要安装3.11.0以上版本的cmake，为了降低团队的协同成本，并不建议在 Android 工程使用，建议使用内部工程的方式引入。</p></blockquote><h2 id="5-CPM"><a href="#5-CPM" class="headerlink" title="5. CPM"></a>5. CPM</h2><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FTheLartians%2FCPM.cmake">CPM.cmake</a> 是在 FetchContent 的基础上封装而来，相比 FetchContent 更加简单易用，使用CPM需要到 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FTheLartians%2FCPM.cmake">CPM.cmake</a> 下载cmake目录的文件CPM.cmake、get_cpm.cmake和testing.cmake，添加到项目当中。</p><h5 id="工程文件目录-4"><a href="#工程文件目录-4" class="headerlink" title="工程文件目录"></a>工程文件目录</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">├── cmake</span><br><span class="line">│   ├── CPM<span class="selector-class">.cmake</span></span><br><span class="line">│   ├── get_cpm<span class="selector-class">.cmake</span></span><br><span class="line">│   └── testing<span class="selector-class">.cmake</span></span><br><span class="line">└── <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><h5 id="CMakeLists-txt-4"><a href="#CMakeLists-txt-4" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.17)</span><br><span class="line">project(cpm_example)</span><br><span class="line">include(cmake/CPM.cmake)</span><br><span class="line"><span class="comment">#CPMAddPackage(</span></span><br><span class="line"><span class="comment">#        GIT_REPOSITORY https://github.com/open-source-parsers/jsoncpp.git</span></span><br><span class="line"><span class="comment">#        GIT_TAG 1.9.4)</span></span><br><span class="line"><span class="comment"># 建议使用压缩包的方式依赖，下载速度更快</span></span><br><span class="line">CPMAddPackage(</span><br><span class="line">        NAME jsoncpp</span><br><span class="line">        URL https://github.com/open-source-parsers/jsoncpp/archive/1.9.4.tar.gz)</span><br><span class="line"></span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> jsoncpp_lib)</span><br></pre></td></tr></table></figure><p>这种方式的细节不需要我们自己处理，都交给了CPM解决，这种方式也同样不建议在 Android 工程使用。</p><p>完整代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftaoweiji%2Fcpp-cmake-example%2Ftree%2Fmaster%2Fcpm">cpm_example</a></p><h2 id="6-find-package"><a href="#6-find-package" class="headerlink" title="6. find_package"></a>6. find_package</h2><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcmake.org%2Fcmake%2Fhelp%2Flatest%2Fcommand%2Ffind_package.html">find_package</a> 是 cmake 3.19.0 版本开始提供的功能，可以非常方便添加，这种方式主要是从本机上查找已经安装好的库，需要提前通过命令安装。</p><h5 id="安装jsoncpp"><a href="#安装jsoncpp" class="headerlink" title="安装jsoncpp"></a>安装jsoncpp</h5><p>我的Mac OS，通过下面方法安装可以成功，其它系统可能会出错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/open-source-parsers/jsoncpp</span><br><span class="line"><span class="built_in">cd</span> jsoncpp</span><br><span class="line"><span class="built_in">mkdir</span> -p build/debug</span><br><span class="line"><span class="built_in">cd</span> build/debug</span><br><span class="line"><span class="comment"># 生成Makefile</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=release -DBUILD_STATIC_LIBS=OFF -DBUILD_SHARED_LIBS=ON -DARCHIVE_INSTALL_DIR=. -DCMAKE_INSTALL_INCLUDEDIR=include -G <span class="string">&quot;Unix Makefiles&quot;</span> ../..</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><p>如果提示没有安装cmake，需要自行安装cmake</p></blockquote><h5 id="工程文件目录-5"><a href="#工程文件目录-5" class="headerlink" title="工程文件目录"></a>工程文件目录</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">└── <span class="selector-tag">main</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><h5 id="CMakeLists-txt-5"><a href="#CMakeLists-txt-5" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.17)</span><br><span class="line">project(find_package_example)</span><br><span class="line">find_package(jsoncpp REQUIRED)</span><br><span class="line">add_executable(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line">target_link_libraries(<span class="variable">$&#123;PROJECT_NAME&#125;</span> jsoncpp_lib)</span><br></pre></td></tr></table></figure><h5 id="完整代码：find-package-example"><a href="#完整代码：find-package-example" class="headerlink" title="完整代码：find_package_example"></a>完整代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Ftaoweiji%2Fcpp-cmake-example%2Ftree%2Fmaster%2Ffind_package">find_package_example</a></h5><blockquote><p>使用这种方式是需要有个大前提，电脑必须已经安装好了对应的库，否则无法正常工作，这种方式只有在特定的场景下使用，比如调用电脑的opencv、openssl。</p></blockquote><h2 id="7-git-submodule"><a href="#7-git-submodule" class="headerlink" title="7. git submodule"></a>7. git submodule</h2><p>这种方式是利用git的submodule实现，推荐Android使用，通过git添加另外一个仓库的依赖，可更新另外一个仓库的依赖，但是代码不会包含进来。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 在A仓库添加B仓库依赖，操作完后需要提交上去</span></span><br><span class="line">git submodule <span class="keyword">add</span> https:<span class="comment">//github.com/taoweiji/B.git</span></span><br></pre></td></tr></table></figure><p>A仓库拉取及submodule仓库的更新</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> https:<span class="comment">//github.com/taoweiji/A.git</span></span><br><span class="line">git submodule init &amp;&amp; git submodule update</span><br></pre></td></tr></table></figure><h2 id="8-Android-动态依赖"><a href="#8-Android-动态依赖" class="headerlink" title="8. Android 动态依赖"></a>8. Android 动态依赖</h2><p><a href="https://www.jianshu.com/p/ad2d0e4958e4">C++工程：以 xlog 为例介绍 Android NDK 如何依赖第三方C++动态库</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++添加依赖的方式有很多种，没有绝对的好与差，应该根据不同的场景使用不同的依赖方式，例如在Android工程中，我们应该尽量不要改变默认的CMake版本，避免增加环境的依赖。</p>]]></content>
      
      
      <categories>
          
          <category> cmake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg剪视频</title>
      <link href="/posts/2e033ba3/"/>
      <url>/posts/2e033ba3/</url>
      
        <content type="html"><![CDATA[<h2 id="自己用过的"><a href="#自己用过的" class="headerlink" title="自己用过的"></a>自己用过的</h2><ol><li>将1：50开始之后的100s内容输出</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -ss 1:05 -i clannad.mp4 -t 100 -c:v copy -c:a copy output.mp4</span><br></pre></td></tr></table></figure><ol><li>将00：20开始之后的内容输出</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -ss 00:20 -i clannad.mp4 -c:v copy -c:a copy output.mp4</span><br></pre></td></tr></table></figure><ol><li>字幕加入到视频</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mkv -i subtitles.srt -c copy output.mkv</span><br></pre></td></tr></table></figure><ol><li>烧录像进字幕</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mkv -vf subtitles=subtitles.srt output.mkv</span><br><span class="line">#显卡加速</span><br><span class="line">ffmpeg -c:v h264_cuvid -i input.mkv -vf subtitles=subtitles.srt -c:v h264_nvenc output.mkv</span><br></pre></td></tr></table></figure><ol><li>提取字幕</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mkv output.srt</span><br></pre></td></tr></table></figure><ol><li>显卡加速</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i input.mkv output.mp4</span><br><span class="line">ffmpeg  -y  -i 002-SpringBoot课程简介.avi -vcodec h264_nvenc  1.mp4</span><br></pre></td></tr></table></figure><p><strong>硬编码后缀解释</strong></p><ul><li><code>qsv</code>：intel显卡的快速视频同步技术（quick sync video）</li><li><code>nvenc</code>：nvidia显卡的硬件视频编码器（nvidia hardware video encoder）</li><li><code>cuvid</code>：nvdec的旧称，只有解码端。</li><li><code>cuda</code>： 同上</li><li><code>amf</code>：amd显卡的amf硬件编码器（amd hardware encoder）</li></ul><blockquote><p>基本上所有的Intel 电脑都支持qsv方式。</p></blockquote><h5 id="各种剪视频方式"><a href="#各种剪视频方式" class="headerlink" title="各种剪视频方式"></a>各种剪视频方式</h5><p>MP4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">速度测试：</span><br><span class="line">ffmpeg  -y  -i 动态代理-01-日常生活中代理例子.avi  1.mp4</span><br><span class="line">cpu:15.2x</span><br><span class="line"></span><br><span class="line">ffmpeg  -y  -i 动态代理-01-日常生活中代理例子.avi -vcodec h264_nvenc 1.mp4</span><br><span class="line">h264_nvenc：23.8x</span><br><span class="line"></span><br><span class="line">使用 NVDEC 和 NVENC 进行全硬件转码：</span><br><span class="line">ffmpeg -y -hwaccel cuda -hwaccel_output_format cuda -i 动态代理-01-日常生活中代理例子.avi -c:v h264_nvenc  1.mp4</span><br><span class="line">cuda:24.5x</span><br></pre></td></tr></table></figure><p>mkv(比较快)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">速度测试：</span><br><span class="line">ffmpeg  -y  -i 动态代理-01-日常生活中代理例子.avi  1.mkv</span><br><span class="line">cpu:36.8x</span><br><span class="line"></span><br><span class="line">ffmpeg  -y  -i 动态代理-01-日常生活中代理例子.avi -vcodec h264_nvenc 1.mkv</span><br><span class="line">h264_nvenc：81.4x</span><br><span class="line"></span><br><span class="line">使用 NVDEC 和 NVENC 进行全硬件转码：</span><br><span class="line">ffmpeg -y -hwaccel cuda -hwaccel_output_format cuda -i 动态代理-01-日常生活中代理例子.avi -c:v h264_nvenc  1.mkv</span><br><span class="line">cuda:83.6x</span><br></pre></td></tr></table></figure><p>不同格式速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg  -y  -i 动态代理-01-日常生活中代理例子.avi -vcodec h264_nvenc 1.mp4</span><br><span class="line">mp4:23.8x</span><br><span class="line"></span><br><span class="line">ffmpeg  -y  -i 动态代理-01-日常生活中代理例子.avi -vcodec h264_nvenc 1.mkv</span><br><span class="line">mkv:82.3x</span><br></pre></td></tr></table></figure><p>文件大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkv:10044kb</span><br><span class="line">mp4:23108kb</span><br></pre></td></tr></table></figure><h5 id="硬件加速命令"><a href="#硬件加速命令" class="headerlink" title="硬件加速命令"></a>硬件加速命令</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -hwaccel cuvid -c:v h264_cuvid -i <span class="built_in">input</span>.mp4 -c:v h264_nvenc -b:v <span class="number">2048</span>k -s <span class="number">1920</span>x1080 <span class="built_in">output</span>.mp4</span><br></pre></td></tr></table></figure><h6 id="常用命令参数解释"><a href="#常用命令参数解释" class="headerlink" title="常用命令参数解释"></a>常用命令参数解释</h6><ul><li><code>-hwaccel cuvid</code>：使用<code>cuvid</code>进行硬件加速</li><li><code>-c:v h264_cuvid</code>：使用<code>h264_cuvid</code>进行解码</li><li><code>-c:v h264_nvenc</code>：使用<code>h264_nvenc</code>进行编码（nvidia硬件加速x265）</li><li><code>-b:v 2000k</code>：比特率，值越大约清晰。</li><li><code>-s 1920x1080</code>：分辨率</li><li><code>-b:v 3500K</code>    ：视频平均比特率为 3500K</li><li><code>-bufsize 6000K</code>：缓存区大小 6000K，建议设定为 当前码率<em>帧率</em>5，也许这里的2pass是针对缓冲区的，缓存未来5s</li><li><code>-maxrate 5000K</code>：最大码率为 5000K，每帧的最高码率不超过这个数值</li><li><code>-preset slow</code>：预设方案是 slow，slow已经是最好的选项了</li><li><code>-pix_fmt p010le</code>：输出的像素格式是 p010le 也就10bit，只有新的硬件支持，例如：970m不支持，1070可以支持</li></ul><p>控制台播放视频：</p><p>ffmpeg -i badapple.mp4 -pix_fmt rgb24 -f caca /dev/stdout</p><h2 id="ffplay命令播放媒体"><a href="#ffplay命令播放媒体" class="headerlink" title="ffplay命令播放媒体"></a>ffplay命令播放媒体</h2><p>播放本地文件</p><p>ffplay -window_title “test time” -ss 2 -t 10 -autoexit test.mp4</p><p>ffplay buweishui.mp3</p><p>播放网络流</p><p>ffplay -window_title “rtmp stream” rtmp://202.69.69.180:443/webcast/bshdlive-pc</p><p>强制解码器</p><p>mpeg4解码器：ffplay -vcodec mpeg4 test.mp4</p><p>h264解码器：ffplay -vcodec h264 test.mp4</p><p>禁用音频或视频</p><p>禁用音频：ffplay test.mp4 -an</p><p>禁用视频：ffplay test.mp4 -vn</p><p>播放YUV数据</p><p>ffplay -pixel_format yuv420p -video_size 320x240 -framerate 5 yuv420p_320x240.yuv</p><p>播放RGB数据</p><p>ffplay -pixel_format rgb24 -video_size 320x240 -i rgb24_320x240.rgb</p><p>ffplay -pixel_format rgb24 -video_size 320x240 -framerate 5 -i rgb24_320x240.rgb</p><p>播放PCM数据</p><p>ffplay -ar 48000 -ac 2 -f f32le 48000_2_f32le.pcm</p><p>-ar set audio sampling rate (in Hz) (from 0 to INT_MAX) (default 0)</p><p>-ac set number of audio channels (from 0 to INT_MAX) (default 0)</p><h2 id="ffplay简单过滤器"><a href="#ffplay简单过滤器" class="headerlink" title="ffplay简单过滤器"></a>ffplay简单过滤器</h2><p>视频旋转</p><p>ffplay -i test.mp4 -vf transpose=1</p><p>视频反转</p><p>ffplay test.mp4 -vf hflip</p><p>ffplay test.mp4 -vf vflip</p><p>视频旋转和反转</p><p>ffplay test.mp4 -vf hflip,transpose=1</p><p>音频变速播放</p><p>ffplay -i test.mp4 -af atempo=2</p><p>视频变速播放</p><p>ffplay -i test.mp4 -vf setpts=PTS/2</p><p>音视频同时变速</p><p>ffplay -i test.mp4 -vf setpts=PTS/2 -af atempo=2</p><h2 id="ffmpeg命令参数说明"><a href="#ffmpeg命令参数说明" class="headerlink" title="ffmpeg命令参数说明"></a>ffmpeg命令参数说明</h2><p><img src="v2-d34d10d4ef6669e8180edef9e83945fc_720w.jpg" alt="img"></p><h2 id="ffmpeg命令-提取音视频数据"><a href="#ffmpeg命令-提取音视频数据" class="headerlink" title="ffmpeg命令 提取音视频数据"></a>ffmpeg命令 提取音视频数据</h2><p>保留封装格式</p><p>ffmpeg -i test.mp4 -acodec copy -vn audio.mp4</p><p>ffmpeg -i test.mp4 -vcodec copy -an video.mp4</p><p>提取视频</p><p>保留编码格式：ffmpeg -i test.mp4 -vcodec copy -an test_copy.h264</p><p>强制格式：ffmpeg -i test.mp4 -vcodec libx264 -an test.h264</p><p>提取音频</p><p>保留编码格式：ffmpeg -i test.mp4 -acodec copy -vn test.aac</p><p>强制格式：ffmpeg -i test.mp4 -acodec libmp3lame -vn test.mp3</p><h2 id="ffmpeg命令提取像素格式和PCM数据"><a href="#ffmpeg命令提取像素格式和PCM数据" class="headerlink" title="ffmpeg命令提取像素格式和PCM数据"></a>ffmpeg命令提取像素格式和PCM数据</h2><p><strong>ffmpeg命令提取像素格式</strong></p><p>提取YUV</p><p>提取3秒数据，分辨率和源视频一致</p><p>ffmpeg -i test_1280x720.mp4 -t 3 -pix_fmt yuv420p yuv420p_orig.yuv</p><p>提取3秒数据，分辨率转为320x240</p><p>ffmpeg -i test_1280x720.mp4 -t 3 -pix_fmt yuv420p -s 320x240 yuv420p_320x240.yuv</p><p>提取RGB</p><p>提取3秒数据，分辨率转为320x240</p><p>ffmpeg -i test.mp4 -t 3 -pix_fmt rgb24 -s 320x240 rgb24_320x240.rgb</p><p>RGB和YUV之间的转换</p><p>ffmpeg -s 320x240 -pix_fmt yuv420p -i yuv420p_320x240.yuv -pix_fmt rgb24 rgb24_320x240_2.rgb</p><p><strong>提取PCM</strong></p><p>ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -f s16le 48000_2_s16le.pcm</p><p>ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -sample_fmt s16 out_s16.wav</p><p>ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -codec:a pcm_s16le out2_s16le.wav</p><p>ffmpeg -i buweishui.mp3 -ar 48000 -ac 2 -f f32le 48000_2_f32le.pcm</p><p>ffmpeg -i test.mp4 -t 10 -vn -ar 48000 -ac 2 -f f32le 48000_2_f32le_2.pcm</p><h2 id="ffmpeg命令转封装"><a href="#ffmpeg命令转封装" class="headerlink" title="ffmpeg命令转封装"></a>ffmpeg命令转封装</h2><p><strong>ffmpeg命令转封装</strong></p><p>保持编码格式：</p><p>ffmpeg -i test.mp4 -vcodec copy -acodec copy test_copy.ts</p><p>ffmpeg -i test.mp4 -codec copy test_copy2.ts</p><p>改变编码格式：</p><p>ffmpeg -i test.mp4 -vcodec libx265 -acodec libmp3lame out_h265_mp3.mkv</p><p>修改帧率：</p><p>ffmpeg -i test.mp4 -r 15 -codec copy output.mp4 (错误命令)</p><p>ffmpeg -i test.mp4 -r 15 output2.mp4</p><p>修改视频码率：</p><p>ffmpeg -i test.mp4 -b 400k output_b.mkv （此时音频也被重新编码）</p><p>修改视频码率：</p><p>ffmpeg -i test.mp4 -b:v 400k output_bv.mkv</p><p>修改音频码率：</p><p>ffmpeg -i test.mp4 -b:a 192k output_ba.mp4</p><p>如果不想重新编码video，需要加上-vcodec copy</p><p>修改音视频码率：</p><p>ffmpeg -i test.mp4 -b:v 400k -b:a 192k output_bva.mp4</p><p>修改视频分辨率：</p><p>ffmpeg -i test.mp4 -s 480x270 output_480x270.mp4</p><p>修改音频采样率:</p><p>ffmpeg -i test.mp4 -ar 44100 output_44100hz.mp4</p><h2 id="ffmpeg命令过滤器"><a href="#ffmpeg命令过滤器" class="headerlink" title="ffmpeg命令过滤器"></a>ffmpeg命令过滤器</h2><p><strong>生成测试文件</strong></p><p>找三个不同的视频每个视频截取10秒内容</p><p>ffmpeg -i 沙海02.mp4 -ss 00:05:00 -t 10 -codec copy 1.mp4</p><p>ffmpeg -i 复仇者联盟3.mp4 -ss 00:05:00 -t 10 -codec copy 2.mp4</p><p>ffmpeg -i 红海行动.mp4 -ss 00:05:00 -t 10 -codec copy 3.mp4</p><p>如果音视频格式不统一则强制统一为 -vcodec libx264 -acodec aac</p><p>将上述1.mp4/2.mp4/3.mp4转成ts格式</p><p>ffmpeg -i 1.mp4 -codec copy -vbsf h264_mp4toannexb 1.ts</p><p>ffmpeg -i 2.mp4 -codec copy -vbsf h264_mp4toannexb 2.ts</p><p>ffmpeg -i 3.mp4 -codec copy -vbsf h264_mp4toannexb 3.ts</p><p>转成flv格式</p><p>ffmpeg -i 1.mp4 -codec copy 1.flv</p><p>ffmpeg -i 2.mp4 -codec copy 2.flv</p><p>ffmpeg -i 3.mp4 -codec copy 3.flv</p><p>分离某些封装格式（例如MP4/FLV/MKV等）中的H.264的时候，需要首先写入SPS和PPS，否则会导致分离出来的数据没有SPS、PPS而无法播放。H.264码流的SPS和PPS信息存储在AVCodecContext结构体的extradata中。需要使用ffmpeg中名称为“h264_mp4toannexb”的bitstream filter处理</p><p><strong>开始拼接文件</strong></p><p>以MP4格式进行拼接</p><p>方法1：ffmpeg -i “concat:1.mp4|2.mp4|3.mp4” -codec copy out_mp4.mp4</p><p>方法2：ffmpeg -f concat -i mp4list.txt -codec copy out_mp42.mp4</p><p>以TS格式进行拼接</p><p>方法1：ffmpeg -i “concat:1.ts|2.ts|3.ts” -codec copy out_ts.mp4</p><p>方法2：ffmpeg -f concat -i tslist.txt -codec copy out_ts2.mp4</p><p>以FLV格式进行拼接</p><p>方法1：ffmpeg -i “concat:1.flv|2.flv|3.flv” -codec copy out_flv.mp4</p><p>方法2：ffmpeg -f concat -i flvlist.txt -codec copy out_flv2.mp4</p><p>方法1只适用部分封装格式，比如TS</p><p>建议：</p><p>（1）使用方法2进行拼接</p><p>（2）转成TS格式再进行拼接</p><p><strong>测试不同编码拼接</strong></p><p>修改音频编码</p><p>ffmpeg -i 2.mp4 -vcodec copy -acodec ac3 -vbsf h264_mp4toannexb 2.ts</p><p>ffmpeg -i “concat:1.ts|2.ts|3.ts” -codec copy out1.mp4 结果第二段没有声音</p><p>修改音频采样率</p><p>ffmpeg -i 2.mp4 -vcodec copy -acodec aac -ar 96000 -vbsf h264_mp4toannexb 2.ts</p><p>ffmpeg -i “concat:1.ts|2.ts|3.ts” -codec copy out2.mp4 第二段播放异常</p><p>修改视频编码格式</p><p>ffmpeg -i 1.mp4 -acodec copy -vcodec libx265 1.ts</p><p>ffmpeg -i “concat:1.ts|2.ts|3.ts” -codec copy out3.mp4</p><p>修改视频分辨率</p><p>ffmpeg -i 1.mp4 -acodec copy -vcodec libx264 -s 800x472 -vbsf h264_mp4toannexb 1.ts</p><p>ffmpeg -i “concat:1.ts|2.ts|3.ts” -codec copy out4.mp4</p><p>注意：</p><p>把每个视频封装格式也统一为ts，拼接输出的时候再输出你需要的封装格式，比如MP4</p><p>视频分辨率可以不同，但是编码格式需要统一</p><p>音频编码格式需要统一，音频参数(采样率/声道等)也需要统一</p><h2 id="fmpeg命令图片与视频互转"><a href="#fmpeg命令图片与视频互转" class="headerlink" title="fmpeg命令图片与视频互转"></a>fmpeg命令图片与视频互转</h2><p>截取一张图片</p><p>ffmpeg -i test.mp4 -y -f image2 -ss 00:00:02 -vframes 1 -s 640x360 test.jpg</p><p>ffmpeg -i test.mp4 -y -f image2 -ss 00:00:02 -vframes 1 -s 640x360 test.bmp</p><p>-i 输入</p><p>-y 覆盖</p><p>-f 格式 image2 一种格式</p><p>-ss 起始值</p><p>-vframes 帧 如果大于1 那么 输出加%03d test%03d.jpg</p><p>-s 格式大小size</p><p>转换视频为图片（每帧一张图):　　</p><p>ffmpeg -i test.mp4 -t 5 -s 640x360 -r 15 frame%03d.jpg</p><p>图片转换为视频:　　</p><p>ffmpeg -f image2 -i frame%03d.jpg -r 25 video.mp4</p><p>从视频中生成GIF图片</p><p>ffmpeg -i test.mp4 -t 5 -r 1 image1.gif</p><p>ffmpeg -i test.mp4 -t 5 -r 25 -s 640x360 image2.gif</p><p>将 GIF 转化为 视频</p><p>ffmpeg -f gif -i image2.gif image2.mp4</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/ternence_hsu/article/details/104111073">ffmpeg可支持的编码器、解码器、封装格式、网络协议_Ternence_Hsu的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/117523405">FFMPEG命令入门到提高，一篇文章就够了 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/u013699869/article/details/48162417">[FFmpeg] Windows下使用ffmpeg为视频添加字幕_SunrayME的专栏-CSDN博客_ffmpeg添加字幕</a></p><p><a href="http://jdjx.run/index.php/archives/321/">使用 FFmpeg 为视频添加字幕 - Hello World (jdjx.run)</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/posts/38a918c7/"/>
      <url>/posts/38a918c7/</url>
      
        <content type="html"><![CDATA[<h3 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h3><p>基本在原本new/delete成对出现的场合使用智能指针替代原始指针</p><h3 id="动态数组使用智能指针"><a href="#动态数组使用智能指针" class="headerlink" title="动态数组使用智能指针"></a>动态数组使用智能指针</h3><p><strong>c++17之前</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//指定 default_delete 作为释放规则</span><br><span class="line">std::shared_ptr&lt;int&gt; p6(new int[10], std::default_delete&lt;int[]&gt;());</span><br><span class="line">//或者</span><br><span class="line">std::shared_ptr&lt;int&gt; p7(new int[10], [](int* p) &#123;delete[]p; &#125;);</span><br><span class="line">//访问的时候要</span><br><span class="line">p6.get()[0]这样</span><br><span class="line"></span><br><span class="line">//使用</span><br><span class="line">std::shared_ptr&lt;int&gt; array = std::shared_ptr&lt;int&gt;(new int[10],</span><br><span class="line">default_delete&lt;int[]&gt;());</span><br><span class="line">//访问的时候要</span><br><span class="line">array.get()[0]这样</span><br><span class="line"></span><br><span class="line">//下面的写法也可以，如果可以推荐这样写</span><br><span class="line">std::shared_ptr&lt;int[]&gt; array = std::shared_ptr&lt;int[]&gt;(new int[10]());</span><br><span class="line">//直接可以访问</span><br><span class="line">array[0]</span><br></pre></td></tr></table></figure><p>不过这么做的缺点也是很明显的：</p><ol><li>我们想管理的值是int[]类型的，然而事实上传给模板参数的是int</li><li>需要显示提供delete functor</li><li>不能使用<code>std::make_shared</code>，无法保证异常安全</li><li>c++17前shared_ptr未提供<code>opreator[]</code>，所以当需要类似操作时不得不使用<code>sp3.get()[index]</code>的形式</li></ol><p><strong>c++17可以这样写</strong>（不知道为啥我的c++14也可以用这样的）</p><p><strong>我也推荐的方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int[]&gt; sp3(new int[10]());</span><br><span class="line">//下面的写法也可以</span><br><span class="line">std::shared_ptr&lt;int[]&gt; array = std::shared_ptr&lt;int[]&gt;(new int[10]());</span><br><span class="line">cout&lt;&lt;sp3[5]&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>使用被极大得简化了，然而还是有点问题，那就是无法使用<code>std::make_shared</code>，而我们除非指定自己的delete functor，否则我们应该尽量使用<code>std::make_shared</code>。</p><p>或者使用<strong>unique_ptr</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int[]&gt; ptr = make_unique&lt;int[]&gt;(10);</span><br></pre></td></tr></table></figure><p>或者使用vector</p><p><strong>c++20可以这样写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//管理有10个int元素的动态数组的shared_ptr</span><br><span class="line">auto sp3 = std::make_shared&lt;int[]&gt;(10);</span><br></pre></td></tr></table></figure><p>非常好用</p><h3 id="C-11-std-make-shared的优点"><a href="#C-11-std-make-shared的优点" class="headerlink" title="C++11_std::make_shared的优点"></a>C++11_std::make_shared的优点</h3><h4 id="shared-ptr维护引用计数需要的信息"><a href="#shared-ptr维护引用计数需要的信息" class="headerlink" title="shared_ptr维护引用计数需要的信息"></a>shared_ptr维护引用计数需要的信息</h4><ul><li>强引用, 用来记录当前有多少个存活的 shared_ptrs 正持有该对象. 共享的对象会在最后一个强引用离开的时候销毁( 也可能释放).</li><li>弱引用, 用来记录当前有多少个正在观察该对象的 weak_ptrs. 当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放 (共享的对象也会被释放, 如果还没有释放的话).</li></ul><h4 id="使用原始的new函数创建shared-ptr"><a href="#使用原始的new函数创建shared-ptr" class="headerlink" title="使用原始的new函数创建shared_ptr"></a>使用原始的new函数创建shared_ptr</h4><ul><li>首先是原始的new分配了原始对象, 然后将这个对象传递给 shared_ptr (即使用 shared_ptr 的构造函数) , shared_ptr 对象只能单独的分配控制块。</li><li>控制块包含被指向对象的引用计数以及其他，也就是说，控制块的内存是在std::shared_ptr的构造函数中分配的。</li></ul><p><img src="4163397-bba22bc2e365d520.webp" alt="4163397-bba22bc2e365d520"></p><h4 id="使用make-shared创建shared-ptr"><a href="#使用make-shared创建shared-ptr" class="headerlink" title="使用make_shared创建shared_ptr"></a>使用make_shared创建shared_ptr</h4><ul><li>如果选择使用 make_shared 的话, 内存分配的动作, 可以一次性完成，因为std::make_shared申请一个单独的内存块来同时存放指向的对象和控制块，这减少了内存分配的次数, 而内存分配是代价很高的操作。</li><li>同时，使用std::make_shared消除了一些控制块需要记录的信息，减少了程序的总内存占用。</li></ul><p><img src="4163397-510c6d6692ca96af.webp" alt="4163397-510c6d6692ca96af"></p><h4 id="make-shared实现异常安全"><a href="#make-shared实现异常安全" class="headerlink" title="make_shared实现异常安全"></a>make_shared实现异常安全</h4><ul><li>在shared_ptr的使用过程中，不能在函数实参中创建shared_ptr，如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Define</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Lhs&gt;&amp; lhs, <span class="type">const</span> std::shared_ptr&lt;Rhs&gt;&amp; rhs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Call</span></span><br><span class="line"><span class="built_in">F</span>(std::<span class="built_in">shared_ptr</span>&lt;Lhs&gt;(<span class="keyword">new</span> <span class="built_in">Lhs</span>(<span class="string">&quot;foo&quot;</span>)),std::<span class="built_in">shared_ptr</span>&lt;Rhs&gt;(<span class="keyword">new</span> <span class="built_in">Rhs</span>(<span class="string">&quot;bar&quot;</span>)));</span><br></pre></td></tr></table></figure><p>C++ 是不保证参数求值顺序, 以及内部表达式的求值顺序的, 所以可能的执行顺序如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Lhs</span>(“foo”))</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Rhs</span>(“bar”))</span><br><span class="line">std::shared_ptr&lt;Lhs&gt;</span><br><span class="line">std::shared_ptr&lt;Rhs&gt;</span><br></pre></td></tr></table></figure><p>如果在第2步的时候，发生了异常，第一步申请的 Lhs 对象内存就泄露了，<br> 产生这个问题的核心在于, shared_ptr 没有立即获得裸指针，所以就有可能产生内存泄漏。当然，这个问题是可以这样解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lhs = std::<span class="built_in">shared_ptr</span>&lt;Lhs&gt;(<span class="keyword">new</span> <span class="built_in">Lhs</span>(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line"><span class="keyword">auto</span> rhs = std::<span class="built_in">shared_ptr</span>&lt;Rhs&gt;(<span class="keyword">new</span> <span class="built_in">Rhs</span>(<span class="string">&quot;bar&quot;</span>));</span><br><span class="line"><span class="built_in">F</span>(lhs, rhs);</span><br></pre></td></tr></table></figure><p><strong>但，最推荐的做法是</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">F</span>(std::<span class="built_in">make_shared</span>&lt;Lhs&gt;(<span class="string">&quot;foo&quot;</span>), std::<span class="built_in">make_shared</span>&lt;Rhs&gt;(<span class="string">&quot;bar&quot;</span>));</span><br></pre></td></tr></table></figure><p>因为，申请原始对象和将原始对象裸指针赋值给shared_ptr是在同一个执行序列里，失败的话一起失败，成功就一起成功，<strong>这样就能保住创建的原始对象裸指针能安全的存放到std::shared_ptr中</strong></p><h4 id="使用make-shared的缺点"><a href="#使用make-shared的缺点" class="headerlink" title="使用make_shared的缺点"></a>使用make_shared的缺点</h4><ul><li>创建的对象如果没有公有的构造函数时，make_shared无法使用。</li><li>使用make_shared内存可能无法及时回收，对内存要求要的场景需要注意。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>智能指针尽量不要指向vector容器类型，因为当vector扩容时，智能指针便不再生效，引起程序的崩溃或未定义的行为。</p><h3 id="new-int-10-和new-int-10-区别"><a href="#new-int-10-和new-int-10-区别" class="headerlink" title="new int[10]和new int[10]()区别"></a>new int[10]和new int[10]()区别</h3><p>new int[10]的值初始化后-1760269552 683 -1760296624 683 0 0 0 0 0 0不全为0；</p><p>new int[10]()初始化后0 0 0 0 0 0 0 0 0 0 全为0</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/apocelipes/p/10346928.html">shared_ptr和动态数组 - apocelipes - 博客园 (cnblogs.com)</a></p><p><a href="http://c.biancheng.net/view/7898.html">C++11 shared_ptr智能指针（超级详细） (biancheng.net)</a></p><p><a href="https://www.jianshu.com/p/8f0a67e26a8a">C++11_std::make_shared的优点 - 简书 (jianshu.com)</a></p><p><a href="https://www.coder.work/article/837321">c++ - make_unique 和 make_shared 处理数组时的区别 - IT工具网 (coder.work)</a></p><p><a href="https://www.cyhone.com/articles/right-way-to-use-cpp-smart-pointer/">C++ 智能指针的正确使用方式 | 编程沉思录 (cyhone.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行代码让vector自带下标范围检查</title>
      <link href="/posts/3af1ab35/"/>
      <url>/posts/3af1ab35/</url>
      
        <content type="html"><![CDATA[<h1 id="一行代码让vector自带下标范围检查"><a href="#一行代码让vector自带下标范围检查" class="headerlink" title="一行代码让vector自带下标范围检查"></a>一行代码让vector自带下标范围检查</h1><p><code>#include &lt;vector&gt;</code>前<code>#define _GLIBCXX_DEBUG</code>就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GLIBCXX_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> t = a[<span class="number">3</span>]; <span class="comment">// runtime error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在cmake传递参数<code>add_definitions(-D_GLIBCXX_DEBUG)</code>开启</p><h2 id="GLIBCXX-DEBUG说明"><a href="#GLIBCXX-DEBUG说明" class="headerlink" title="_GLIBCXX_DEBUG说明"></a>_GLIBCXX_DEBUG说明</h2><p><code>_GLIBCXX_DEBUG</code>是一个用于启用C++标准库的调试模式的宏定义。当定义了这个宏时，会启用GCC（GNU Compiler Collection）中libstdc++标准库的调试模式，该模式提供了一些额外的运行时检查来捕获一些常见的C++程序错误，如数组越界、迭代器失效等。</p><p>在使用<code>_GLIBCXX_DEBUG</code>时，编译器会对标准库的数据结构和操作进行更严格的检查，这可能会导致性能下降，但有助于发现和调试潜在的程序错误。</p><p>需要注意的是，使用<code>_GLIBCXX_DEBUG</code>会导致程序的执行速度变慢，并且会增加一些内存开销，因为额外的检查会增加程序的运行时负担。通常情况下，只有在调试阶段才会使用<code>_GLIBCXX_DEBUG</code>来帮助捕获和修复一些难以发现的错误。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vcpkg清单模式指定安装版本</title>
      <link href="/posts/c50f0d51/"/>
      <url>/posts/c50f0d51/</url>
      
        <content type="html"><![CDATA[<p>可以使用清单模式,然后在overrides里面指定需要的版本。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kys-cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version-semver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fmt&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;9.1.0&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;builtin-baseline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;da21e45c9ae689f63aa27f3a4ee0e64fe6b16494&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vcpkg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vcpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt中嵌入osgearth</title>
      <link href="/posts/2f877652/"/>
      <url>/posts/2f877652/</url>
      
        <content type="html"><![CDATA[<p>d</p><p>待续</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>osg-qt的安装</title>
      <link href="/posts/58f37cd6/"/>
      <url>/posts/58f37cd6/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OSG-Qt 是一个集成了 OpenSceneGraph (OSG) 和 Qt 的库，使得开发者能够在 Qt 应用程序中轻松地使用 OpenSceneGraph 进行 3D 图形渲染。OpenSceneGraph 是一个开源的、跨平台的 3D 图形应用程序编程接口（API），广泛用于游戏开发、模拟、虚拟现实、科学可视化等领域。Qt 是一个跨平台的 C++ 应用程序开发框架，用于开发具有图形用户界面的应用程序，也可用于开发无界面的后台应用。</p><h2 id="windows中安装"><a href="#windows中安装" class="headerlink" title="windows中安装"></a>windows中安装</h2><h3 id="使用vcpkg安装（推荐）"><a href="#使用vcpkg安装（推荐）" class="headerlink" title="使用vcpkg安装（推荐）"></a>使用vcpkg安装（推荐）</h3><p>vcpkg的安装见 <a href="https://jinianyoushang.github.io/posts/67c5155/">使用vcpkg管理C++项目依赖 | xd’s blog (jinianyoushang.github.io)</a></p><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install osg-qt</span><br></pre></td></tr></table></figure><p>之后在cmake中执行 <code>find_package(OpenSceneGraph REQUIRED osgQt)</code>时会报错无法找到osgQt</p><p>可以根据<a href="https://www.cnblogs.com/yaoyu126/p/15102195.html#:~:text=使用CMake查找osgQt146 在osg3.6.5中，osgQt已经分离为单独的子项目，其146版本使用了QOpenGL，其使用的头文件与生成的库与旧版osgQt相比，都发生了变化。 需要对 findosgqt.cmake 文件进行修改，才能正常使用 find_package (osgQt">使用CMake查找osgQt146 - 一花一世界,一叶一乾坤 - 博客园 (cnblogs.com)</a>,或 find_package (OpenSceneGraph 3.6.5 REQUIRE osgQt) 。)解决</p><p>也就是修改<code>findosgqt.cmake</code>文件</p><p>我的在这里</p><p>C:\Program Files\JetBrains\CLion 2023.2\bin\cmake\win\x64\share\cmake-3.28\Modules\</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># findosgqt.cmake</span></span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/Findosg_functions.cmake)</span><br><span class="line">OSG_FIND_PATH   (OSGQT osgQOpenGL/osgQOpenGLWidget)</span><br><span class="line">OSG_FIND_LIBRARY(OSGQT osgQOpenGL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/FindPackageHandleStandardArgs.cmake)</span><br><span class="line">FIND_PACKAGE_HANDLE_STANDARD_ARGS(osgQt DEFAULT_MSG</span><br><span class="line">    OSGQT_LIBRARY OSGQT_INCLUDE_DIR)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>待续</p><h2 id="linux安装"><a href="#linux安装" class="headerlink" title="linux安装"></a>linux安装</h2><p>待续</p><p>在cmake中执行 <code>find_package(OpenSceneGraph REQUIRED osgQt)</code>时会报错无法找到osgQt,解决方法同windows。</p>]]></content>
      
      
      <categories>
          
          <category> osg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> osg </tag>
            
            <tag> osg-qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>osgEarth在windows的安装</title>
      <link href="/posts/c9ef61f0/"/>
      <url>/posts/c9ef61f0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OSGEarth是一个开源的地理空间软件库，它基于著名的3D图形工具库OpenSceneGraph（OSG）。OSGEarth主要用于创建地理空间可视化应用程序，包括地球模拟、地图浏览、地理信息系统（GIS）数据可视化等。它利用OpenSceneGraph提供的3D图形渲染能力，允许开发者构建高性能、高质量的地理空间3D可视化效果。</p><p>OSGEarth是一个开源的地理空间软件库，它基于著名的3D图形工具库OpenSceneGraph（OSG）。OSGEarth主要用于创建地理空间可视化应用程序，包括地球模拟、地图浏览、地理信息系统（GIS）数据可视化等。它利用OpenSceneGraph提供的3D图形渲染能力，允许开发者构建高性能、高质量的地理空间3D可视化效果。</p><h2 id="1-使用vcpkg安装（推荐）"><a href="#1-使用vcpkg安装（推荐）" class="headerlink" title="1. 使用vcpkg安装（推荐）"></a>1. 使用vcpkg安装（推荐）</h2><h3 id="安装vcpkg"><a href="#安装vcpkg" class="headerlink" title="安装vcpkg"></a>安装vcpkg</h3><p><a href="https://github.com/Microsoft/vcpkg">microsoft/vcpkg: C++ Library Manager for Windows, Linux, and MacOS (github.com)</a></p><p><a href="https://jinianyoushang.github.io/posts/67c5155/">使用vcpkg管理C++项目依赖 | xd’s blog (jinianyoushang.github.io)</a></p><h3 id="修改vcpkg中osg的配置文件"><a href="#修改vcpkg中osg的配置文件" class="headerlink" title="修改vcpkg中osg的配置文件"></a>修改vcpkg中osg的配置文件</h3><p>由于osgEarth需要osg支持GL3 或者GLCORE模式，即核心模式</p><p>可以修改vcpkg中以下文件<code>path\to\vcpkg\triplets\x64-windows.cmake</code> ,添加下列配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(osg_OPENGL_PROFILE GL3)</span><br></pre></td></tr></table></figure><h3 id="安装osg-和osgEarth"><a href="#安装osg-和osgEarth" class="headerlink" title="安装osg 和osgEarth"></a>安装osg 和osgEarth</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install osg osgearth </span><br></pre></td></tr></table></figure><p>如果要完全安装osg 和osgearth所有组件，则可以执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install osgearth[blend2d,default-features,tools] osg[collada,default-features,docs,examples,fontconfig,nvtt,openexr,packages,plugins,sdl1,tools] osg-qt gdal  osg-qt</span><br></pre></td></tr></table></figure><h3 id="在Visual-studio中使用"><a href="#在Visual-studio中使用" class="headerlink" title="在Visual studio中使用"></a>在Visual studio中使用</h3><p>vcpkg默认会配置好依赖，直接使用即可</p><h3 id="在cmake项目使用"><a href="#在cmake项目使用" class="headerlink" title="在cmake项目使用"></a>在cmake项目使用</h3><p>注意，编译器要选择msvc</p><p>在CMakeLists中配置vcpkg，需要注意把vcpkg的配置信息放在project之前，如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>.<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(VCPKG_ROOT <span class="string">&quot;E:/vcpkg&quot;</span>)            <span class="comment"># 手动设置到你的vcpkg根目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="string">&quot;$&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(MyProject LANGUAGES CXX)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="查找osg-osgearth"><a href="#查找osg-osgearth" class="headerlink" title="查找osg osgearth"></a>查找osg osgearth</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置OpenSceneGraph  osgQt</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenSceneGraph REQUIRED</span><br><span class="line">        osg osgGA osgDB osgViewer osgUtil osgText</span><br><span class="line">        osgVolume osgTerrain osgSim osgFX osgAnimation osgManipulator osgParticle</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        <span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">        <span class="variable">$&#123;OPENSCENEGRAPH_LIBRARIES&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">set</span>(VCPKG_ROOT <span class="string">&quot;C:/softwares/vcpkg-master&quot;</span>)            <span class="comment"># 手动设置到你的vcpkg根目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="string">&quot;$&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;</span>)</span><br><span class="line"><span class="keyword">project</span>(simple_earth)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#msvc支持中文 utf8</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置OpenGL</span></span><br><span class="line"><span class="comment">#find_package(OpenGL REQUIRED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置OpenSceneGraph  osgQt</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenSceneGraph REQUIRED</span><br><span class="line">        osg osgGA osgDB osgViewer osgUtil osgText</span><br><span class="line">        osgVolume osgTerrain osgSim osgFX osgAnimation osgManipulator osgParticle</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OPENSCENEGRAPH_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;OpenSceneGraph Include Directories: $&#123;OPENSCENEGRAPH_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#osgEarth</span></span><br><span class="line"><span class="keyword">find_package</span>(osgEarth CONFIG REQUIRED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">        <span class="variable">$&#123;OPENSCENEGRAPH_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(CMAKE_BUILD_TYPE <span class="keyword">STREQUAL</span> <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Debug build&quot;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;osgEarth_LIBRARIES_DEBUG&#125;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(CMAKE_BUILD_TYPE <span class="keyword">STREQUAL</span> <span class="string">&quot;Release&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Release build&quot;</span>)</span><br><span class="line">    <span class="comment"># 添加你的 Release 模式下的配置</span></span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;osgEarth_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;Unknown build type: $&#123;CMAKE_BUILD_TYPE&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;osgEarth_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="variable">$&#123;osgEarth_LIBRARIES_DEBUG&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="variable">$&#123;osgEarth_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgViewer/Viewer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/Notify&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/EarthManipulator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/MapNode&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/Threading&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/ShaderGenerator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/Metrics&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/GDAL&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/XYZ&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> osgEarth;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> osgEarth::Util;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 OSG 日志级别</span></span><br><span class="line">    osg::<span class="built_in">setNotifyLevel</span>(osg::DEBUG_FP); <span class="comment">// 可以替换为其他级别</span></span><br><span class="line"></span><br><span class="line">    osgEarth::<span class="built_in">initialize</span>();</span><br><span class="line">    <span class="comment">//create a viewer</span></span><br><span class="line">    osgViewer::Viewer viewer;</span><br><span class="line">    viewer.<span class="built_in">setUpViewInWindow</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="comment">// ? why</span></span><br><span class="line">    viewer.<span class="built_in">setReleaseContextAtEndOfFrameHint</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//set camera manipulator</span></span><br><span class="line">    viewer.<span class="built_in">setCameraManipulator</span>(<span class="keyword">new</span> EarthManipulator);</span><br><span class="line">    <span class="comment">// Map is datamodel for collection of layers.</span></span><br><span class="line">    osg::ref_ptr&lt;osgEarth::Map&gt; rootMap = <span class="keyword">new</span> osgEarth::Map;</span><br><span class="line">    <span class="comment">//XYZ</span></span><br><span class="line">    osg::ref_ptr&lt;XYZImageLayer&gt; someLayer = <span class="keyword">new</span> XYZImageLayer;</span><br><span class="line">    someLayer-&gt;<span class="built_in">setURL</span>(osgEarth::<span class="built_in">URI</span>(<span class="string">&quot;http://[abc].tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&quot;</span>));</span><br><span class="line">    someLayer-&gt;<span class="built_in">setProfile</span>(osgEarth::Profile::<span class="built_in">create</span>(Profile::SPHERICAL_MERCATOR));</span><br><span class="line">    <span class="comment">// MapNode is the render or visualization of Map.</span></span><br><span class="line">    osg::ref_ptr&lt;osgEarth::MapNode&gt; rootMapNode = <span class="keyword">new</span> osgEarth::<span class="built_in">MapNode</span>(rootMap.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">    rootMap-&gt;<span class="built_in">addLayer</span>(someLayer);</span><br><span class="line">    viewer.<span class="built_in">setSceneData</span>(rootMapNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//? what</span></span><br><span class="line">    <span class="keyword">return</span> Metrics::<span class="built_in">run</span>(viewer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-手动编译安装"><a href="#2-手动编译安装" class="headerlink" title="2.手动编译安装"></a>2.手动编译安装</h2><p>待完成</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://freesouth.blog.csdn.net/article/details/118732591?spm=1001.2014.3001.5502">第23节 编译-《OSG&amp;OE编译一本通V1.42》永久性解决编译问题_osg和oe-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> osg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> osg </tag>
            
            <tag> osgEarth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决vcpkg网络不好的方法</title>
      <link href="/posts/919153de/"/>
      <url>/posts/919153de/</url>
      
        <content type="html"><![CDATA[<p>由于vcpkg安装C++库的时候需要访问github下载相关文件，而网络环境通常较差，导致下载缓慢或者中断。</p><p>以下是解决方法</p><h2 id="1-手动下载"><a href="#1-手动下载" class="headerlink" title="1.手动下载"></a>1.手动下载</h2><p>这个办法通常用来处理某个库下载失败的情况。</p><p>将安装过程链接手动下载，放到downloads文件夹。</p><p>如<a href="https://github.com/OSGeo/gdal/archive/v3.8.3.tar.gz">https://github.com/OSGeo/gdal/archive/v3.8.3.tar.gz</a> 。</p><p>手动下载后放到 vcpkg-master\downloads\ 中，然后重新安装即可。</p><p>但是当有的包依赖多的时候，这个办法不好。</p><h2 id="2-先下载，后编译"><a href="#2-先下载，后编译" class="headerlink" title="2.先下载，后编译"></a>2.先下载，后编译</h2><p>分两步</p><p>例如，你要安装 ceres，分两步：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vcpkg.exe install ceres <span class="literal">--only-downloads</span></span><br><span class="line">vcpkg.exe install ceres</span><br></pre></td></tr></table></figure><h2 id="3-使用代理（推荐）"><a href="#3-使用代理（推荐）" class="headerlink" title="3.使用代理（推荐）"></a>3.使用代理（推荐）</h2><p>使用clash的TUN模式，可以对整个电脑的流量进行代理。</p><p><img src="image-20240323192157025.png" alt="image-20240323192157025"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通常来说，可以使用第三种方式结合第一种。也就是如果打开代理之后还下载失败，就可以使用手动下载解决。</p>]]></content>
      
      
      <categories>
          
          <category> vcpkg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vcpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux设置开机自启动命令</title>
      <link href="/posts/eae3c50a/"/>
      <url>/posts/eae3c50a/</url>
      
        <content type="html"><![CDATA[<h2 id="方法一：修改-etc-rc-d-rc-local-文件"><a href="#方法一：修改-etc-rc-d-rc-local-文件" class="headerlink" title="方法一：修改 /etc/rc.d/rc.local 文件"></a>方法一：修改 /etc/rc.d/rc.local 文件</h2><p><code>/etc/rc.d/rc.local</code> 文件会在 Linux 系统各项服务都启动完毕之后再被运行。所以你想要自己的脚本在开机后被运行的话，可以将自己脚本路径加到该文件里。</p><p>但是，首先需要确认你有运行这个文件的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><p>为了演示，我们创建了一个脚本，当它被执行之后，将在家目录下写入有特定信息的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vim auto_run_script.sh</span><br><span class="line"> </span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">date</span> &gt;&gt; /home/alvin/output.txt</span><br><span class="line">hostname &gt;&gt; /home/alvin/output.txt</span><br></pre></td></tr></table></figure><p>保存退出后，再给它赋予可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x auto_run_script.sh</span><br></pre></td></tr></table></figure><p>然后，我们再将脚本添加到 <code>/etc/rc.d/rc.local</code> 文件最后一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/rc.d/rc.local</span><br><span class="line"> </span><br><span class="line">/home/alvin/auto_run_script.sh</span><br></pre></td></tr></table></figure><p>接下来，我们就可以试试效果了。直接重启系统就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo reboot</span></span><br></pre></td></tr></table></figure><p>重启之后，就会在家目录下看到脚本执行的结果了。</p><p><img src="1ddea68a904c04ddf6ecea4cb804834e.jpeg" alt="img"></p><h2 id="方法二：使用-crontab"><a href="#方法二：使用-crontab" class="headerlink" title="方法二：使用 crontab"></a>方法二：使用 crontab</h2><p>大家知道，crontab 是 Linux 下的计划任务，当时间达到我们设定的时间时，可以自动触发某些脚本的运行。</p><p>我们可以自己设置计划任务时间，然后编写对应的脚本。但是，有个特殊的任务，叫作 <code>@reboot</code> ，我们其实也可以直接从它的字面意义看出来，这个任务就是在系统重启之后自动运行某个脚本。</p><p>那它将运行的是什么脚本呢？我们如何去设置这个脚本呢？我们可以通过 <code>crontab -e</code> 来设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">crontab -e</span></span><br><span class="line"> </span><br><span class="line">@reboot /home/alvin/auto_run_script.sh</span><br></pre></td></tr></table></figure><p>然后，直接重启即可。运行的效果跟上面类似。</p><h2 id="方法三：使用-systemd-服务"><a href="#方法三：使用-systemd-服务" class="headerlink" title="方法三：使用 systemd 服务"></a>方法三：使用 systemd 服务</h2><p>以上介绍的两种方法，在任何 Linux 系统上都可以使用。但本方法仅适用于 systemd 系统。</p><p>为了实现目的，我们需要创建一个 systemd 启动服务，并把它放置在 <code>/etc/systemd/system/</code> 目录下。</p><p>我们创建的 systemd 启动服务如下。请注意，这时后缀是 <code>.service</code> ，而不是 <code>.sh</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim auto_run_script.service</span></span><br><span class="line"> </span><br><span class="line">[Unit]</span><br><span class="line">Description=Run a Custom Script at Startup</span><br><span class="line">After=default.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/alvin/auto_run_script.sh</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure><p>从服务的内容可以看出来，我们最终还是会调用 /home/alvin/auto_run_script.sh 这个脚本。</p><p>然后，我们再把这个脚本放置在 <code>/etc/systemd/systerm/</code> 目录下，之后我们再运行下面两条命令来更新 systemd 配置文件，并启动服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">systemctl <span class="built_in">enable</span> auto_run_script.service</span></span><br></pre></td></tr></table></figure><p>万事俱备之后，我们就可以重启系统啦。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">reboot</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/yychuyu/p/13095732.html">Linux系统如何设置开机自动运行脚本？ - 良许Linux - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 开机自启动 </tag>
            
            <tag> systemd </tag>
            
            <tag> crontab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows设置自己的程序开机自动启动</title>
      <link href="/posts/1301a31d/"/>
      <url>/posts/1301a31d/</url>
      
        <content type="html"><![CDATA[<p>Windows系统想要快速设置开机自动启动某个程序，可以使用以下几种方法设置：</p><h2 id="第一种：设置启动项-推荐"><a href="#第一种：设置启动项-推荐" class="headerlink" title="第一种：设置启动项(推荐)"></a>第一种：设置启动项(推荐)</h2><p>1.找到启动文件夹，我的是<code>C:\Users\ThinkPad\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>，或者打开运行，输入<code>shell:startup</code>，回车，也可以快速打开启动文件夹。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3cGtqaW8=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>2.拷贝需要开机启动的程序的快捷方式到此文件夹即可。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3cGtqaW8=,size_16,color_FFFFFF,t_70-17105540196293.png" alt="img"></p><p>3.打开任务管理器-启动查看启动项。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3cGtqaW8=,size_16,color_FFFFFF,t_70-17105540381136.png" alt="img"></p><p>这样就设置好了，下次计算机启动时，程序也会自动启动的。</p><h2 id="第二种：使用计划任务自启动"><a href="#第二种：使用计划任务自启动" class="headerlink" title="第二种：使用计划任务自启动"></a>第二种：使用计划任务自启动</h2><p>1.新建文本文件DebugStart.txt,打开写入以下内容：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist|<span class="built_in">find</span> /i &quot;authSender.exe&quot; &amp;&amp; <span class="built_in">echo</span> started || <span class="built_in">start</span> &quot;&quot; &quot;D:\Debug\authSender.exe&quot;。</span><br></pre></td></tr></table></figure><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3cGtqaW8=,size_16,color_FFFFFF,t_70-17105541552299.png" alt="img"></p><p>这条语句不能换行， authSender.exe 是程序名， “D:\Debug\authSender.exe”是此程序所在路径，tasklist|find /i “authSender.exe”是判断进程是否存在，程序是否已经开启，如未开启才会启动程序，然后改后缀名 .txt 为 .bat，双击即可启动程序。(可以在每条语句前使用 :: 来注释一条语句)，这种方法还可以批量启动不同程序，只需要在此文件中重启一行，按相同格式写第二个要启动的程序对应的语句即可。</p><p>2.进入任务计划程序窗口，创建任务。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3cGtqaW8=,size_16,color_FFFFFF,t_70-171055419572812.png" alt="img"></p><p>接着选择触发器选项卡，选择新建，在第一栏开始任务处选择登录时（启动时开始任务需要管理员权限）或启动时（启动时开始任务需要管理员权限），点击确定。由于我们的 <code>bat</code>脚本有做判断，所以不用担心程序会启动多次。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3cGtqaW8=,size_16,color_FFFFFF,t_70-171055421017315.png" alt="img"></p><p>在操作选项卡选择新建，并选择启动程序选项，以及在程序和脚本处选择刚才编写的.bat程序，点击确定，然后再点击确定（创建任务界面的确定）。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x3cGtqaW8=,size_16,color_FFFFFF,t_70-171055421951018.png" alt="img"></p><p>关闭页面，即可做到开机自动启动程序。</p><h2 id="第三种：添加服务自动运行"><a href="#第三种：添加服务自动运行" class="headerlink" title="第三种：添加服务自动运行"></a>第三种：添加服务自动运行</h2><p>1.开始—-运行—-<a href="https://so.csdn.net/so/search?q=cmd&amp;spm=1001.2101.3001.7020">cmd</a>—-回车，在弹出的窗体中输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create Debug binPath= D:\Debug\authSender.exe start= auto</span><br></pre></td></tr></table></figure><p>其中Debug为将要创建的服务名。要删除创建的服务也很简单，使用以下命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc delete ServiceName</span><br></pre></td></tr></table></figure><p>2.打开控制面板—-管理工具—-服务（或者 开始—-运行—-<code>services.msc</code>—-确认）打开服务管理器，看看你创建的服务已经在里面了，至此，服务运行已创建完成。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/lwpkjio/article/details/85129507">Windows设置自己的程序开机自动启动_开机自启动-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> 自动启动 </tag>
            
            <tag> 开机启动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++项目目录结构</title>
      <link href="/posts/f6d25693/"/>
      <url>/posts/f6d25693/</url>
      
        <content type="html"><![CDATA[<h4 id="自己的想法"><a href="#自己的想法" class="headerlink" title="自己的想法"></a>自己的想法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">|--3rdparty </span><br><span class="line">|--build#用于存放第三方库，每个第三库以单独目录的形式组织在3rdparty目录下</span><br><span class="line">|--doc          # 文档目录，存放项目相关的文档</span><br><span class="line">|--include      # 公共头文件目录，按模块划分子目录</span><br><span class="line">|--lib          # 外部依赖库目录</span><br><span class="line">|--res          # 资源目录，存放图片、音频、字体等资源文件</span><br><span class="line">|--samples      # 样例程序目录，展示项目的用法</span><br><span class="line">|--src          # 源代码目录，按模块划分子目录</span><br><span class="line">|--test         # 测试目录，存放单元测试和集成测试代码</span><br><span class="line">|--tools        # 工具目录，存放项目支撑工具</span><br><span class="line">|--copyleft     # 版权声明文件</span><br><span class="line">|--CMakeLists.txt   # CMake构建配置文件</span><br><span class="line">|--README.md    # 项目自述文件</span><br></pre></td></tr></table></figure><p>其中src</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下面可以为</span><br><span class="line">include以及源文件</span><br></pre></td></tr></table></figure><ul><li><strong>3rdparty :</strong> 用于存放第三方库，每个第三库以单独目录的形式组织在3rdparty目录下。其中每个第三方目录下又有 <code>include</code> 和 <code>lib</code> 分别存放第三方库的头文件和库文件。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">project_name</span><br><span class="line">├── deploy</span><br><span class="line">├── build</span><br><span class="line">├── doc</span><br><span class="line">├── 3rdparty</span><br><span class="line">├── include</span><br><span class="line">│   └── project_name</span><br><span class="line">├── project_name</span><br><span class="line">├── tools</span><br><span class="line">├── scripts</span><br><span class="line">├── platforms</span><br><span class="line">├── test</span><br><span class="line">├── LICENSE</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── build.sh</span><br><span class="line">├── toolchain.cmake</span><br><span class="line">├── .gitignore</span><br><span class="line">├── readme.md</span><br><span class="line">└── sample</span><br></pre></td></tr></table></figure><ul><li><strong>deploy :</strong> 用于存放部署、交付的文件，其包含子目录bin、lib、include分别存放本项目最总生成的可执行文件、库文件以及对外所提供的头文件。</li><li><strong>build :</strong> 用于存放build时cmake产生的中间文件，其包含子目录release和debug。</li><li><strong>doc :</strong> 用于存放项目的相关文档。</li><li><strong>3rdparty :</strong> 用于存放第三方库，每个第三库以单独目录的形式组织在3rdparty目录下。其中每个第三方目录下又有 <code>include</code> 和 <code>lib</code> 分别存放第三方库的头文件和库文件。</li><li><strong>include/project_name :</strong> 用于存放每个模块以及整个工程对外的头文件。具体格式如下文。</li><li><strong>project_name :</strong> 存放源码文件，以及内部头文件。具体格式如下文。</li><li><strong>tools :</strong> 包含一些支持项目构建的工具，如编译器等，一般情况下使用软链接。</li><li><strong>scripts :</strong> 包含一些脚本文件，如使用Jenkins进行自动化构建时所需要的脚本文件，以及一些用于预处理的脚本文件。</li><li><strong>platforms :</strong> 用于一些交叉编译时所需要的工具链等文件，按照平台进行划分来组织子目录。每个子目录下存放 <code>toolchain.cmake</code> 等用于指定平台的文件。</li><li><strong>test :</strong> 分模块存放测试代码。</li><li><strong>LICENSE :</strong> 版权信息说明。</li><li><strong>CMakeLists.txt :</strong> cmake文件。</li><li><strong>build.sh :</strong> build脚本文件。</li><li><strong>.gitignore :</strong> 指明git忽略规则。</li><li><strong>readme.md :</strong> 存放工程说明文件。</li><li><strong>sample :</strong> 存放示例代码。</li></ul><h4 id="参考2"><a href="#参考2" class="headerlink" title="参考2"></a>参考2</h4><p><a href="https://zhuanlan.zhihu.com/p/59450618">C++项目的组织方式可能因为项目的规模、类型、目标平台等因素而有所不同，但是一般来说，一个良好的C++项目应该遵循以下几个原则</a><a href="https://zhuanlan.zhihu.com/p/59450618">1</a>：</p><ul><li>有一个清晰的目录结构，区分不同的部分，如源代码、头文件、文档、资源、测试、工具等。</li><li>有一个可靠的构建系统，可以根据不同的环境生成相应的Makefile或者项目文件，如使用CMake、Makefile、Visual Studio等。</li><li>有一个合理的依赖管理，避免不必要的头文件包含，使用相对路径或者预定义的变量来引用外部库或者模块。</li><li>有一个完善的文档，说明项目的功能、用法、协议、注意事项等。</li><li>有一个规范的代码风格，遵循一致的命名规则、缩进规则、注释规则等。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/59450618">一个可能的C++项目目录结构示例</a><a href="https://zhuanlan.zhihu.com/p/59450618">1</a><a href="https://zhuanlan.zhihu.com/p/36382087">2</a>如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">project</span><br><span class="line">|--build        # 项目编译目录，存放临时文件和目标文件</span><br><span class="line">|--dist         # 分发目录，存放最终发布的可执行程序和运行支持文件</span><br><span class="line">|--doc          # 文档目录，存放项目相关的文档</span><br><span class="line">|--include      # 公共头文件目录，按模块划分子目录</span><br><span class="line">|--lib          # 外部依赖库目录</span><br><span class="line">|--res          # 资源目录，存放图片、音频、字体等资源文件</span><br><span class="line">|--samples      # 样例程序目录，展示项目的用法</span><br><span class="line">|--src          # 源代码目录，按模块划分子目录</span><br><span class="line">|--test         # 测试目录，存放单元测试和集成测试代码</span><br><span class="line">|--tools        # 工具目录，存放项目支撑工具</span><br><span class="line">|--copyleft     # 版权声明文件</span><br><span class="line">|--CMakeLists.txt   # CMake构建配置文件</span><br><span class="line">|--README.md    # 项目自述文件</span><br><span class="line">#自己加的</span><br><span class="line">|-bin  二进制文件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参见下面的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">project —+—build—+—debug</span><br><span class="line">　　　　　|　　　　　|—release</span><br><span class="line">　　　　　|—dist</span><br><span class="line">　　　　　|—doc</span><br><span class="line">　　　　　|—include—+—module1</span><br><span class="line">　　　　　|　　　　　　|—module2</span><br><span class="line">　　　　　|—lib</span><br><span class="line">　　　　　|—module1</span><br><span class="line">　　　　　|—module2</span><br><span class="line">　　　　　|—res</span><br><span class="line">　　　　　|—samples—+—sample1</span><br><span class="line">　　　　　|　　　　　　|—sample2</span><br><span class="line">　　　　　|—tools</span><br><span class="line">　　　　　|—copyleft</span><br><span class="line">　　　　　|—Makefile</span><br><span class="line">　　　　　|—README</span><br></pre></td></tr></table></figure><h4 id="参考3"><a href="#参考3" class="headerlink" title="参考3"></a>参考3</h4><p><a href="https://zhuanlan.zhihu.com/p/59450618">干货：构建C/C++良好的工程结构 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/xiaolongtuan/article/details/45094887">C++项目目录组织结构_xiaolongtuan的博客-CSDN博客</a></p><p><a href="https://github.com/hattonl/cpp-project-structure">hattonl/cpp-project-structure: C++工程目录结构规范示例 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 项目结构 </tag>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python切换镜像源</title>
      <link href="/posts/e8700fde/"/>
      <url>/posts/e8700fde/</url>
      
        <content type="html"><![CDATA[<p>在国内使用python官方源速度太慢，可以使用镜像源，本文以<code>北师大镜像</code>为例说明镜像源的使用</p><ul><li>个人体验来说，北师大镜像源速度要比阿里和清华的要快。</li></ul><h2 id="PyPI-镜像使用帮助"><a href="#PyPI-镜像使用帮助" class="headerlink" title="PyPI 镜像使用帮助"></a>PyPI 镜像使用帮助</h2><p>PyPI 镜像在每次同步成功后间隔 5 分钟同步一次。</p><h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><h4 id="临时使用"><a href="#临时使用" class="headerlink" title="临时使用"></a>临时使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://mirrors.bfsu.edu.cn/pypi/web/simple some-package</span><br></pre></td></tr></table></figure><p>注意，<code>simple</code> 不能少, 是 <code>https</code> 而不是 <code>http</code></p><h4 id="设为默认"><a href="#设为默认" class="headerlink" title="设为默认"></a>设为默认</h4><p>升级 pip 到最新的版本 (&gt;=10.0.0) 后进行配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br><span class="line">pip config set global.index-url https://mirrors.bfsu.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure><p>如果您到 pip 默认源的网络连接较差，临时使用本镜像站来升级 pip：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -i https://mirrors.bfsu.edu.cn/pypi/web/simple --upgrade pip</span><br></pre></td></tr></table></figure><h4 id="配置多个镜像源"><a href="#配置多个镜像源" class="headerlink" title="配置多个镜像源"></a>配置多个镜像源</h4><p>如果您想配置多个镜像源平衡负载，可在已经替换 <code>index-url</code> 的情况下通过以下方式继续增加源站：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip config set global.extra-index-url &quot;&lt;url1&gt; &lt;url2&gt;...&quot;</span><br></pre></td></tr></table></figure><p>请自行替换引号内的内容，源地址之间需要有空格</p><p>可用的 <code>pypi</code> 源列表（校园网联合镜像站）：<a href="https://mirrors.cernet.edu.cn/list/pypi">https://mirrors.cernet.edu.cn/list/pypi</a></p><h3 id="PDM"><a href="#PDM" class="headerlink" title="PDM"></a>PDM</h3><p>通过如下命令设置默认镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdm config pypi.url https://mirrors.bfsu.edu.cn/pypi/web/simple</span><br></pre></td></tr></table></figure><h3 id="Poetry"><a href="#Poetry" class="headerlink" title="Poetry"></a>Poetry</h3><p>通过以下命令设置默认镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry source add --priority=default mirrors https://mirrors.bfsu.edu.cn/pypi/web/simple/</span><br></pre></td></tr></table></figure><p>通过以下命令设置次级镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry source add --priority=secondary mirrors https://mirrors.bfsu.edu.cn/pypi/web/simple/</span><br></pre></td></tr></table></figure><h3 id="常用镜像源"><a href="#常用镜像源" class="headerlink" title="常用镜像源"></a>常用镜像源</h3><p>清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><p>阿里云：<a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a></p><p>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></p><p>华中理工大学：<a href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a></p><p>山东理工大学：<a href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a></p><p>豆瓣：<a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p><p>注意：新版 Ubuntu 要求使用https源。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mirrors.bfsu.edu.cn/help/pypi/">pypi | 镜像站使用帮助 | 北京外国语大学开源软件镜像站 | BFSU Open Source Mirror</a></p><p><a href="https://www.cnblogs.com/chenjo/p/14071864.html">Python 国内镜像源 - jetwill - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 镜像源 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Studio CMake中文UTF8编码设置</title>
      <link href="/posts/42ff7d67/"/>
      <url>/posts/42ff7d67/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>使用Cmake调用MSVC编译utf-8格式的cpp文件时，如果里面有中文会编译出错。如下图：</p><p><img src="image-20240314094223549.png" alt="image-20240314094223549"></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>文件-高级保存选项，选择utf-8编码，无签名格式</li><li>在<strong>add_executable之前</strong>加入:</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#msvc支持中文 utf8</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> cmake </tag>
            
            <tag> UTF8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中使用Redis</title>
      <link href="/posts/175acaf3/"/>
      <url>/posts/175acaf3/</url>
      
        <content type="html"><![CDATA[<h1 id="在Docker中使用Redis"><a href="#在Docker中使用Redis" class="headerlink" title="在Docker中使用Redis"></a>在Docker中使用Redis</h1><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>本文章将介绍如何使用 Docker 探索 Redis。我们可以在 Docker for Windows 、Docker for mac 或者 Linux 模式下运行 Docker 命令。</p><blockquote><p> 本文是基于Docker for mac。 </p></blockquote><h3 id="2-查看可用的-Redis-版本"><a href="#2-查看可用的-Redis-版本" class="headerlink" title="2. 查看可用的 Redis 版本"></a>2. 查看可用的 Redis 版本</h3><p>可以在<a href="https://cloud.tencent.com/product/tcr?from=10680">镜像仓库</a>中查看 <a href="https://hub.docker.com/_/redis?tab=tags">Redis</a> 镜像：</p><p><img src="1620.png" alt="img"></p><h3 id="3-获取镜像"><a href="#3-获取镜像" class="headerlink" title="3. 获取镜像"></a>3. 获取镜像</h3><p>使用如下命令拉取官方最新版本的镜像：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="attr">redis</span>:latest</span><br></pre></td></tr></table></figure><p><img src="1620-16645387358191.png" alt="img"></p><h3 id="4-查看本地镜像"><a href="#4-查看本地镜像" class="headerlink" title="4. 查看本地镜像"></a>4. 查看本地镜像</h3><p>使用如下命令来查看是否已安装了Redis镜像：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="1620-16645387358192.png" alt="img"></p><p>在图中我们可以看到我们已经安装了最新版本（latest）的 Redis 镜像。</p><h3 id="5-运行容器"><a href="#5-运行容器" class="headerlink" title="5. 运行容器"></a>5. 运行<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a></h3><p>我们给容器起一个名字 <code>docker-redis</code>，同时公开 6379 端口（Redis 默认值），使用如下命令运行容器:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p <span class="number">6379</span>:<span class="number">6379</span> --name docker-redis redis</span><br></pre></td></tr></table></figure><p><img src="1620-16645387358193.png" alt="img"></p><blockquote><p> -p 6379:6379：映射容器服务的 6379 端口到<a href="https://cloud.tencent.com/product/cdh?from=10680">宿主机</a>的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。 </p></blockquote><p>可以通过如下命令查看容器的运行信息来判断容器是否运行成功：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="1620-16645387358204.png" alt="img"></p><p>还可以通过如下命令查看日志输出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs docker-redis</span><br></pre></td></tr></table></figure><p><img src="1620-16645387358205.png" alt="img"></p><h3 id="6-在容器中运行Redis-CLI"><a href="#6-在容器中运行Redis-CLI" class="headerlink" title="6. 在容器中运行Redis CLI"></a>6. 在容器中运行Redis CLI</h3><p>接着我们通过在容器中运行 redis-cli 来连接 redis 服务。我们将在运行中的容器中用 <code>-it</code> 选项来启动一个新的交互式会话，并使用它来运行 <code>redis-cli</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it docker-redis /bin/bash</span><br></pre></td></tr></table></figure><p><img src="1620-16645387358206.png" alt="img"></p><p>我们已经连接到容器，现在让我们运行 <code>redis-cli</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@517350<span class="attr">f4f2bb</span>:/data# redis-cli</span><br></pre></td></tr></table></figure><p>现在我们可以运行一些基本的 Redis 命令：</p><p><img src="1620-16645387358207.png" alt="img"></p><h3 id="7-清理容器"><a href="#7-清理容器" class="headerlink" title="7. 清理容器"></a>7. 清理容器</h3><p>让我们停止 <code>docker-redis</code> 容器并删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop docker-redis</span><br><span class="line">docker rm docker-redis</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己的docker笔记高级</title>
      <link href="/posts/3cd00b76/"/>
      <url>/posts/3cd00b76/</url>
      
        <content type="html"><![CDATA[<h3 id="一）-MySQL主从复制"><a href="#一）-MySQL主从复制" class="headerlink" title="(一） MySQL主从复制"></a>(一） MySQL主从复制</h3><h5 id="1-新建主从服务器容器实例3307"><a href="#1-新建主从服务器容器实例3307" class="headerlink" title="1.新建主从服务器容器实例3307"></a>1.新建主从服务器容器实例3307</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#实战版启动</span><br><span class="line">docker run -p 3307:3306 --name mysql-master \</span><br><span class="line">-v /mydata/mysql-master/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-master/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-master/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><h5 id="2-进入-mydata-mysql-master-conf-目录下新建-my-cnf"><a href="#2-进入-mydata-mysql-master-conf-目录下新建-my-cnf" class="headerlink" title="2.进入/mydata/mysql-master/conf 目录下新建 my.cnf"></a>2.进入/mydata/mysql-master/conf 目录下新建 my.cnf</h5><h5 id="vim-my-cnf"><a href="#vim-my-cnf" class="headerlink" title="vim my.cnf"></a>vim my.cnf</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置 server_id，同一局域网中需要唯一</span><br><span class="line">server_id=101 </span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql </span><br><span class="line">## 开启二进制日志功能</span><br><span class="line">log-bin=mall-mysql-bin </span><br><span class="line">## 设置二进制日志使用内存大小（事务）116</span><br><span class="line">binlog_cache_size=1M </span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed </span><br><span class="line">## 二进制日志过期清理时间。默认值为 0，表示不自动清理。</span><br><span class="line">expire_logs_days=7 </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免 slave 端复制中断。</span><br><span class="line">## 如：1062 错误是指一些主键重复，1032 错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062</span><br></pre></td></tr></table></figure><h5 id="3-修改完配置后重启-master-实例"><a href="#3-修改完配置后重启-master-实例" class="headerlink" title="3.修改完配置后重启 master 实例"></a>3.修改完配置后重启 master 实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql-master</span><br></pre></td></tr></table></figure><h5 id="4-进入-mysql-master-容器"><a href="#4-进入-mysql-master-容器" class="headerlink" title="4.进入 mysql-master 容器"></a>4.进入 mysql-master 容器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql-master /bin/bash</span><br><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure><h5 id="5-master-容器实例内创建数据同步用户"><a href="#5-master-容器实例内创建数据同步用户" class="headerlink" title="5.master 容器实例内创建数据同步用户"></a>5.master 容器实例内创建数据同步用户</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#新建的用户</span><br><span class="line">CREATE USER &#x27;slave&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#x27;slave&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><h5 id="6-新建从服务器容器实例-3308"><a href="#6-新建从服务器容器实例-3308" class="headerlink" title="6.新建从服务器容器实例 3308"></a>6.新建从服务器容器实例 3308</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3308:3306 --name mysql-slave \</span><br><span class="line">-v /mydata/mysql-slave/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql-slave/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql-slave/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><h5 id="7-进入-mydata-mysql-slave-conf-目录下新建-my-cnf"><a href="#7-进入-mydata-mysql-slave-conf-目录下新建-my-cnf" class="headerlink" title="7.进入/mydata/mysql-slave/conf 目录下新建 my.cnf"></a>7.进入/mydata/mysql-slave/conf 目录下新建 my.cnf</h5><p>vim my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">## 设置 server_id，同一局域网中需要唯一</span><br><span class="line">server_id=102</span><br><span class="line">## 指定不需要同步的数据库名称</span><br><span class="line">binlog-ignore-db=mysql </span><br><span class="line">## 开启二进制日志功能，以备 Slave 作为其它数据库实例的 Master 时使用</span><br><span class="line">log-bin=mall-mysql-slave1-bin </span><br><span class="line">## 设置二进制日志使用内存大小（事务）</span><br><span class="line">binlog_cache_size=1M </span><br><span class="line">## 设置使用的二进制日志格式（mixed,statement,row）</span><br><span class="line">binlog_format=mixed </span><br><span class="line">## 二进制日志过期清理时间。默认值为 0，表示不自动清理。</span><br><span class="line">expire_logs_days=7 </span><br><span class="line">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免 slave 端复制中断。</span><br><span class="line">## 如：1062 错误是指一些主键重复，1032 错误是因为主从数据库数据不一致</span><br><span class="line">slave_skip_errors=1062 </span><br><span class="line">## relay_log 配置中继日志</span><br><span class="line">relay_log=mall-mysql-relay-bin </span><br><span class="line">## log_slave_updates 表示 slave 将复制事件写进自己的二进制日志</span><br><span class="line">log_slave_updates=1 </span><br><span class="line">## slave 设置为只读（具有 super 权限的用户除外）</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure><h5 id="8-修改完配置后重启-master-实例"><a href="#8-修改完配置后重启-master-实例" class="headerlink" title="8.修改完配置后重启 master 实例"></a>8.修改完配置后重启 master 实例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql-slave</span><br></pre></td></tr></table></figure><h5 id="9-在主数据库中查看主从同步状态"><a href="#9-在主数据库中查看主从同步状态" class="headerlink" title="9.在主数据库中查看主从同步状态"></a>9.在主数据库中查看主从同步状态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure><h5 id="10-进入-mysql-slave-容器"><a href="#10-进入-mysql-slave-容器" class="headerlink" title="10.进入 mysql-slave 容器"></a>10.进入 mysql-slave 容器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql-slave /bin/bash</span><br><span class="line">mysql -uroot -proot</span><br></pre></td></tr></table></figure><h5 id="11-在从数据库中配置主从复制"><a href="#11-在从数据库中配置主从复制" class="headerlink" title="11.在从数据库中配置主从复制"></a>11.在从数据库中配置主从复制</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">change master to master_host=&#x27;192.168.113.132&#x27;, </span><br><span class="line">master_user=&#x27;slave&#x27;, </span><br><span class="line">master_password=&#x27;123456&#x27;, master_port=3307, </span><br><span class="line">master_log_file=&#x27;mall-mysql-bin.000001&#x27;, </span><br><span class="line">master_log_pos=617, master_connect_retry=30;</span><br></pre></td></tr></table></figure><p>主从复制命令参数说明</p><p>master_host：主数据库的 IP 地址；<br>master_port：主数据库的运行端口；<br>master_user：在主数据库创建的用于同步数据的用户账号；<br>master_password：在主数据库创建的用于同步数据的用户密码；<br>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取 File 参数；<br>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取 Position 参数；<br>master_connect_retry：连接失败重试的时间间隔，单位为秒。</p><h5 id="12-在从数据库中查看主从同步状态"><a href="#12-在从数据库中查看主从同步状态" class="headerlink" title="12.在从数据库中查看主从同步状态"></a>12.在从数据库中查看主从同步状态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show slave status \G;</span><br><span class="line">show master status \G;</span><br></pre></td></tr></table></figure><p><img src="image-20221001163238904.png" alt="image-20221001163238904"></p><h5 id="13-在从数据库中开启主从同步"><a href="#13-在从数据库中开启主从同步" class="headerlink" title="13.在从数据库中开启主从同步"></a>13.在从数据库中开启主从同步</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><h5 id="14-查看从数据库状态发现已经同步"><a href="#14-查看从数据库状态发现已经同步" class="headerlink" title="14.查看从数据库状态发现已经同步"></a>14.查看从数据库状态发现已经同步</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show slave status \G;</span><br></pre></td></tr></table></figure><p><img src="image-20221001163230550.png" alt="image-20221001163230550"></p><h5 id="15-主从复制测试"><a href="#15-主从复制测试" class="headerlink" title="15.主从复制测试"></a>15.主从复制测试</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#主数据库</span><br><span class="line">create database db01;</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">#从数据库</span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>可以发现两边都有db01 则完成搭配；</p><h3 id="二-安装-redis-集群"><a href="#二-安装-redis-集群" class="headerlink" title="(二) 安装 redis 集群"></a>(二) 安装 redis 集群</h3><h4 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h4><ol><li>哈希取余算法</li><li>一致性哈希算法</li><li>哈希槽分区</li></ol><p>Redis 集群中内置了 16384 个哈希槽</p><h4 id="3-主-3-从-redis-集群扩缩容配置案例架构说明"><a href="#3-主-3-从-redis-集群扩缩容配置案例架构说明" class="headerlink" title="3 主 3 从 redis 集群扩缩容配置案例架构说明"></a>3 主 3 从 redis 集群扩缩容配置案例架构说明</h4><blockquote><p>192.168.113.133 #当前ip</p></blockquote><h5 id="1-关闭防火墙-启动-docker-后台服务"><a href="#1-关闭防火墙-启动-docker-后台服务" class="headerlink" title="1.关闭防火墙+启动 docker 后台服务"></a>1.关闭防火墙+启动 docker 后台服务</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h5 id="2-新建-6-个-docker-容器-redis-实例-6381-6386"><a href="#2-新建-6-个-docker-容器-redis-实例-6381-6386" class="headerlink" title="2.新建 6 个 docker 容器 redis 实例 6381-6386"></a>2.新建 6 个 docker 容器 redis 实例 6381-6386</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis-node-1 --net host --privileged=true -v/data/redis/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-2 --net host --privileged=true -v/data/redis/share/redis-node-2:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6382</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-3 --net host --privileged=true -v/data/redis/share/redis-node-3:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6383</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-4 --net host --privileged=true -v/data/redis/share/redis-node-4:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6384</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-5 --net host --privileged=true -v/data/redis/share/redis-node-5:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6385</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-6 --net host --privileged=true -v/data/redis/share/redis-node-6:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6386</span><br></pre></td></tr></table></figure><h5 id="3-进入容器-redis-node-1-并为-6-台机器构建集群关系"><a href="#3-进入容器-redis-node-1-并为-6-台机器构建集群关系" class="headerlink" title="3.进入容器 redis-node-1 并为 6 台机器构建集群关系"></a>3.进入容器 redis-node-1 并为 6 台机器构建集群关系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-1 /bin/bash</span><br></pre></td></tr></table></figure><p>构建主从关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#注意，进入 docker 容器后才能执行一下命令，且注意自己的真实 IP 地址</span><br><span class="line">redis-cli --cluster create 192.168.113.133:6381 192.168.113.133:6382 192.168.113.133:6383 192.168.113.133:6384 192.168.113.133:6385 192.168.113.133:6386 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p>—cluster-replicas 1 表示为每个 master 创建一个slave 节点</p><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.113.133:6385 to 192.168.113.133:6381</span><br><span class="line">Adding replica 192.168.113.133:6386 to 192.168.113.133:6382</span><br><span class="line">Adding replica 192.168.113.133:6384 to 192.168.113.133:6383</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity</span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: 9fd51f967f366ec1004f2eeb9c20a6fddc23dd7f 192.168.113.133:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: c4b2d4fc07d71c7f7a987e540172e80043218fe1 192.168.113.133:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 53d3fceb6878f37751c5b8b8a62f1718fd0026f9 192.168.113.133:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 8d5845a7ee977850158e479f66301c6c5aad04e9 192.168.113.133:6384</span><br><span class="line">   replicates 9fd51f967f366ec1004f2eeb9c20a6fddc23dd7f</span><br><span class="line">S: 98d7a8627a1e89949127596de339325df2923e9f 192.168.113.133:6385</span><br><span class="line">   replicates c4b2d4fc07d71c7f7a987e540172e80043218fe1</span><br><span class="line">S: dd9a8b9c99ec0192c5a2c78d6c86907e9d31fbdc 192.168.113.133:6386</span><br><span class="line">   replicates 53d3fceb6878f37751c5b8b8a62f1718fd0026f9</span><br><span class="line">Can I set the above configuration? (type &#x27;yes&#x27; to accept): </span><br></pre></td></tr></table></figure><p>输入yes完成</p><h5 id="4-链接进入-6381-作为切入点，查看集群状态"><a href="#4-链接进入-6381-作为切入点，查看集群状态" class="headerlink" title="4.链接进入 6381 作为切入点，查看集群状态"></a>4.链接进入 6381 作为切入点，查看集群状态</h5><p>链接进入 6381 作为切入点，查看节点状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6381</span><br><span class="line">cluster info</span><br><span class="line">cluster nodes</span><br></pre></td></tr></table></figure><h4 id="主从容错切换迁移案例"><a href="#主从容错切换迁移案例" class="headerlink" title="主从容错切换迁移案例"></a>主从容错切换迁移案例</h4><h5 id="数据读写存储"><a href="#数据读写存储" class="headerlink" title="数据读写存储"></a>数据读写存储</h5><p>进入一台主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-1 /bin/bash</span><br></pre></td></tr></table></figure><p>加入-c参数集群方式连接.可以设置kv</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6381 -c</span><br></pre></td></tr></table></figure><p>之后就可以使用集群</p><h5 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.113.133:6381</span><br></pre></td></tr></table></figure><h5 id="主-6381-和从机切换，先停止主机-6381"><a href="#主-6381-和从机切换，先停止主机-6381" class="headerlink" title="主 6381 和从机切换，先停止主机 6381"></a>主 6381 和从机切换，先停止主机 6381</h5><p>主6381停止后，重启后变为从机，6384变为主机</p><p>想要6381变为主机，则应停止6384，后重启6384</p><h4 id="主从扩容"><a href="#主从扩容" class="headerlink" title="主从扩容"></a>主从扩容</h4><h5 id="1-新建-6387、6388-两个节点-新建后启动"><a href="#1-新建-6387、6388-两个节点-新建后启动" class="headerlink" title="1. 新建 6387、6388 两个节点+新建后启动"></a>1. 新建 6387、6388 两个节点+新建后启动</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis-node-7 --net host --privileged=true -v/data/redis/share/redis-node-7:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387</span><br><span class="line"></span><br><span class="line">docker run -d --name redis-node-8 --net host --privileged=true -v /data/redis/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388</span><br><span class="line"></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h5 id="2-进入-6387-容器实例内部"><a href="#2-进入-6387-容器实例内部" class="headerlink" title="2.进入 6387 容器实例内部"></a>2.进入 6387 容器实例内部</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-node-7 /bin/bash</span><br></pre></td></tr></table></figure><h5 id="3-将新增的-6387-节点-空槽号-作为-master-节点加入原集群"><a href="#3-将新增的-6387-节点-空槽号-作为-master-节点加入原集群" class="headerlink" title="3.将新增的 6387 节点(空槽号)作为 master 节点加入原集群"></a>3.将新增的 6387 节点(空槽号)作为 master 节点加入原集群</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#redis-cli --cluster add-node 自己实际IP地址:6387 自己实际IP地址:6381</span><br><span class="line">redis-cli --cluster add-node 192.168.113.133:6387 192.168.113.133:6381</span><br></pre></td></tr></table></figure><p>6387 就是将要作为master新增节点</p><p>6381 就是原来集群节点里面的领路人，相当于6387拜拜6381的码头从而找到组织加入集群</p><p><strong>查看集群信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.113.133:6381</span><br></pre></td></tr></table></figure><p>发现6387没有分配</p><h5 id="4-重新分派槽号"><a href="#4-重新分派槽号" class="headerlink" title="4.重新分派槽号"></a>4.重新分派槽号</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#命令:redis-cli --cluster reshard IP地址:端口号</span><br><span class="line">redis-cli --cluster reshard 192.168.113.133:6381</span><br><span class="line"></span><br><span class="line">#How many slots do you want to move (from 1 to 16384)?</span><br><span class="line">#填入16384/4=4096</span><br><span class="line"></span><br><span class="line">#what is the receiving node ID? </span><br><span class="line">#6387对应的id  b48f64116c034c2e4f8882cb450e08333552d497</span><br><span class="line"></span><br><span class="line">#输入all</span><br><span class="line">yes</span><br></pre></td></tr></table></figure><p><strong>查看集群信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.113.133:6381</span><br></pre></td></tr></table></figure><p>为什么6387是3个新的区间，以前的还是连续？</p><p>重新分配成本太高，所以前3家各自匀出来一部分，从6381/6382/6383三个旧节点分别匀出1364个坑位给新节点6387</p><h5 id="5-为主节点6387分配从节点6388"><a href="#5-为主节点6387分配从节点6388" class="headerlink" title="5.为主节点6387分配从节点6388"></a>5.为主节点6387分配从节点6388</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#命令：redis-cli --cluster add-node ip:新slave端口 ip:新master端口 --cluster-slave --cluster-master-id 新主机节点ID</span><br><span class="line"> </span><br><span class="line">redis-cli --cluster add-node 192.168.113.133:6388 192.168.113.133:6387 --cluster-slave --cluster-master-id b48f64116c034c2e4f8882cb450e08333552d497</span><br><span class="line">#最后的id-------这个是6387的编号，按照自己实际情况</span><br></pre></td></tr></table></figure><p>查看集群信息后发现完成需求</p><h4 id="主从缩容"><a href="#主从缩容" class="headerlink" title="主从缩容"></a>主从缩容</h4><p>目的：将master 6387和slaver 6388下线</p><h5 id="1-检查6388的节点id"><a href="#1-检查6388的节点id" class="headerlink" title="1.检查6388的节点id"></a>1.检查6388的节点id</h5><p><strong>查看集群信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.113.133:6381</span><br></pre></td></tr></table></figure><h5 id="2-将-6388-删除-从集群中将-4-号从节点-6388-删除"><a href="#2-将-6388-删除-从集群中将-4-号从节点-6388-删除" class="headerlink" title="2.将 6388 删除 从集群中将 4 号从节点 6388 删除"></a>2.将 6388 删除 从集群中将 4 号从节点 6388 删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#命令：redis-cli --cluster del-node ip:从机端口 从机6388节点ID </span><br><span class="line">redis-cli --cluster del-node 192.168.113.133:6388 de2c20f6f71299a4105e4762b5b6a3c353b8a95c</span><br></pre></td></tr></table></figure><p>检查一下发现，6388 被删除了，只剩下 7 台机器了。</p><h5 id="3-将-6387-的槽号清空，重新分配，本例将清出来的槽号都给-6381"><a href="#3-将-6387-的槽号清空，重新分配，本例将清出来的槽号都给-6381" class="headerlink" title="3.将 6387 的槽号清空，重新分配，本例将清出来的槽号都给 6381"></a>3.将 6387 的槽号清空，重新分配，本例将清出来的槽号都给 6381</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 192.168.113.133:6381</span><br><span class="line"></span><br><span class="line">#How many slots do you want to move (from 1 to 16384)? 4096</span><br><span class="line">#4096是6387的槽数量</span><br><span class="line"></span><br><span class="line">#what is the receiving node ID? 9fd51f967f366ec1004f2eeb9c20a6fddc23dd7f</span><br><span class="line"></span><br><span class="line">#source node #1: b48f64116c034c2e4f8882cb450e08333552d497</span><br><span class="line">-&gt;done</span><br><span class="line">-&gt;yes</span><br></pre></td></tr></table></figure><p>4096 个槽位都指给 6381，它变成了 8192 个槽位，相当于全部都给 6381 了，不然要输入 3 次，一锅端</p><p><strong>查看集群信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster check 192.168.113.133:6381</span><br></pre></td></tr></table></figure><h5 id="4-将-6387-删除"><a href="#4-将-6387-删除" class="headerlink" title="4.将 6387 删除"></a>4.将 6387 删除</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令：redis-cli --cluster del-node ip:端口 6387节点ID</span><br><span class="line"> </span><br><span class="line">redis-cli --cluster del-node 192.168.113.133:6387 b48f64116c034c2e4f8882cb450e08333552d497</span><br></pre></td></tr></table></figure><p><strong>查看集群信息</strong></p><p>发现已经完成done</p><h3 id="（三）-DockerFile微服务"><a href="#（三）-DockerFile微服务" class="headerlink" title="（三） DockerFile微服务"></a>（三） DockerFile微服务</h3><p>Dockerfile 是用来构建 Docker 镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><h4 id="常用保留字"><a href="#常用保留字" class="headerlink" title="常用保留字"></a>常用保留字</h4><h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><p>基础镜像，当前新镜像是基于哪个镜像的，指定一个已经存在的镜像作为模板，第一条必须是 from</p><h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><p>镜像维护者的姓名和邮箱地址</p><h5 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h5><p>容器构建时需要运行的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#两种格式</span><br><span class="line">#shell 格式</span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">#exec 格式</span><br><span class="line"></span><br><span class="line">#RUN 是在 docker build 时运行</span><br></pre></td></tr></table></figure><p><img src="image-20221002165229030.png" alt="image-20221002165229030"></p><h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><p>当前容器对外暴露出的端口</p><h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><p>指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点</p><h5 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h5><p>指定该镜像以什么样的用户去执行，如果都不指定，默认是 root</p><h5 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h5><p>用来在构建镜像过程中设置环境变量</p><h5 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h5><p>将宿主机目录下的文件拷贝进镜像且会自动处理 URL 和解压 tar 压缩包</p><h5 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h5><p>类似 ADD，拷贝文件和目录到镜像中。 将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置</p><h5 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h5><p>容器数据卷，用于数据保存和持久化工作</p><h5 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h5><p>指定容器启动后的要干的事情</p><p>docker run后面的参数会覆盖此命令里面的内容</p><p>它和前面 RUN 命令的区别<br>• CMD 是在 docker run 时运行。<br>• RUN 是在 docker build 时运行。</p><h5 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h5><p>也是用来指定一个容器启动时要运行的命令</p><p>类似于 CMD 指令，但是 ENTRYPOINT 不会被 docker run 后面的命令覆盖，<br>而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序</p><h4 id="案例-自定义镜像-mycentosjava8"><a href="#案例-自定义镜像-mycentosjava8" class="headerlink" title="案例-自定义镜像 mycentosjava8"></a>案例-自定义镜像 mycentosjava8</h4><h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p>Centos7 镜像具备 vim+ifconfig+jdk8</p><p>JDK 的下载镜像地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.oracle.com/java/technologies/downloads/#java8</span><br><span class="line">https://mirrors.yangxingzhen.com/jdk/</span><br></pre></td></tr></table></figure><h5 id="准备编写-Dockerfile-文件"><a href="#准备编写-Dockerfile-文件" class="headerlink" title="准备编写 Dockerfile 文件"></a>准备编写 Dockerfile 文件</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> xd&lt;xd@<span class="number">126</span>.com&gt;</span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="comment">#修改源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /etc/yum.repos.d/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos8_base.repo</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum clean all &amp;&amp; yum makecache</span></span><br><span class="line"><span class="comment">#安装 vim 编辑器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span></span><br><span class="line"><span class="comment">#安装 ifconfig 命令查看网络 IP</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span></span><br><span class="line"><span class="comment">#安装 java8 及 lib 库</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum -y install glibc.i686</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /usr/local/java</span></span><br><span class="line"><span class="comment">#ADD 是相对路径 jar,把 jdk-8u171-linuxx64.tar.gz 添加到容器中,安装包必须要和Dockerfile 文件在同一位置</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u192-linux-x64.tar.gz /usr/local/java/</span></span><br><span class="line"><span class="comment">#配置 java 环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="number">8.0</span>_192</span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME $JAVA_HOME/jre</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line"><span class="keyword">ENV</span> PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;success--------------ok&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#docker build -t 新镜像名字:TAG .</span><br><span class="line">docker build -t centosjava8:1.5 .</span><br></pre></td></tr></table></figure><h6 id="问题解决：Failed-to-download-metadata-for-repo-‘appstream‘-Cannot-prepare-internal-mirrorlist-…"><a href="#问题解决：Failed-to-download-metadata-for-repo-‘appstream‘-Cannot-prepare-internal-mirrorlist-…" class="headerlink" title="问题解决：Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist:…"></a>问题解决：Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist:…</h6><p><a href="https://cloud.tencent.com/developer/article/1993317">问题解决：Failed to download metadata for repo ‘appstream‘: Cannot prepare internal mirrorlist:… - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line">curl -o  /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo</span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br><span class="line"></span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos8_base.repo</span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure><p><a href="https://mirrors.tencent.com/help/centos.html">CentOS (tencent.com)</a></p><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 新镜像名字:TAG</span><br></pre></td></tr></table></figure><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看</span><br><span class="line">docker image ls -f dangling=true</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><h4 id="ubuntu"><a href="#ubuntu" class="headerlink" title="-ubuntu"></a>-ubuntu</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">MAINTAINER</span> zzyy&lt;zzyybs@<span class="number">126</span>.com&gt;</span><br><span class="line"><span class="keyword">ENV</span> MYPATH /usr/local</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install net-tools</span></span><br><span class="line"><span class="comment">#RUN apt-get install -y iproute2</span></span><br><span class="line"><span class="comment">#RUN apt-get install -y inetutils-ping</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;install inconfig cmd into ubuntu success--------------ok&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><h3 id="（四）微服务实战"><a href="#（四）微服务实战" class="headerlink" title="（四）微服务实战"></a>（四）微服务实战</h3><h3 id="（五）Docker网络"><a href="#（五）Docker网络" class="headerlink" title="（五）Docker网络"></a>（五）Docker网络</h3><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docekr network create 网络名字</span><br></pre></td></tr></table></figure><h5 id="查看网络"><a href="#查看网络" class="headerlink" title="查看网络"></a>查看网络</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure><h5 id="查看网络源数据"><a href="#查看网络源数据" class="headerlink" title="查看网络源数据"></a>查看网络源数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect XXX 网络名字</span><br></pre></td></tr></table></figure><h5 id="删除网络"><a href="#删除网络" class="headerlink" title="删除网络"></a>删除网络</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network rm XXX 网络名字</span><br></pre></td></tr></table></figure><h4 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h4><p>• 容器间的互联和通信以及端口映射<br>• 容器 IP 变动时候可以通过服务名直接网络通信而不受到影响</p><h4 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h4><p><img src="image-20221003110853741.png" alt="image-20221003110853741"></p><p>• bridge 模式：使用—network bridge 指定，默认使用 docker0<br>• host 模式：使用—network host 指定<br>• none 模式：使用—network none 指定<br>• container 模式：使用—network container:NAME 或者容器 ID 指定</p><p>docker 容器内部的 ip 是有可能会发生改变的</p><h4 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h4><p><strong>自定义网络本身就维护好了主机名和 ip 的对应关系（ip 和域名都能通）</strong></p><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d -p 8082:8080 --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><p>互相可ping通，通过名字不可以ping通</p><h5 id="新建自定义网络"><a href="#新建自定义网络" class="headerlink" title="新建自定义网络"></a>新建自定义网络</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  network create xd_network</span><br></pre></td></tr></table></figure><p>新建容器加入上一步新建的自定义网络</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8081:8080 --network xd_network --name tomcat81 billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d -p 8082:8080 --network xd_network --name tomcat82 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><p>互相 ping 测试,可以ping通</p><p><img src="image-20221003114845464.png" alt="image-20221003114845464"></p><p><img src="image-20221003114848689.png" alt="image-20221003114848689"></p><p><strong>自定义网络本身就维护好了主机名和 ip 的对应关系（ip 和域名都能通）</strong></p><p>推荐使用</p><h3 id="（六）Docker-compose-容器编排"><a href="#（六）Docker-compose-容器编排" class="headerlink" title="（六）Docker-compose 容器编排"></a>（六）Docker-compose 容器编排</h3><p>Docker-Compose 是 Docker 官方的开源项目， 负责实现对 Docker 容器集群的快速编排。</p><p>Compose 是 Docker 公司推出的一个工具软件，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的配置文件 docker-compose.yml，写好多个容器之间的调用关系。然后，只要一个命令，就能同时启动/关闭这些容器</p><p>docker 建议我们每一个容器中只运行一个服务,因为docker 容器本身占用资源极少,所以最好是将每个服务单独的分割开来</p><p>Compose 允许用户通过一个单独的 dockercompose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><p>文档</p><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">Compose file version 3 reference | Docker Documentation</a></p><p>官网下载</p><p><a href="https://docs.docker.com/compose/install/">Install Docker Compose | Docker Documentation</a></p><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><h5 id="Install-the-plugin-manually"><a href="#Install-the-plugin-manually" class="headerlink" title="Install the plugin manually"></a>Install the plugin manually</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_CONFIG=$&#123;DOCKER_CONFIG:-$HOME/.docker&#125;</span><br><span class="line">mkdir -p $DOCKER_CONFIG/cli-plugins</span><br><span class="line">curl -SL https://github.com/docker/compose/releases/download/v2.11.2/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose</span><br><span class="line"></span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h5 id="Install-using-the-repository"><a href="#Install-using-the-repository" class="headerlink" title="Install using the repository"></a>Install using the repository</h5><p>Ubuntu, Debian:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install docker-compose-plugin</span><br></pre></td></tr></table></figure><p>RPM-based distros:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install docker-compose-plugin</span><br></pre></td></tr></table></figure><p>Verify that Docker Compose is installed correctly by checking the version.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose version</span><br></pre></td></tr></table></figure><h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><p><a href="https://docs.docker.com/compose/install/uninstall/">Uninstall Docker Compose | Docker Documentation</a></p><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -h                           <span class="comment"># 查看帮助</span></span><br><span class="line">docker-compose up                           <span class="comment"># 启动所有docker-compose服务</span></span><br><span class="line">docker-compose up -d                        <span class="comment"># 启动所有docker-compose服务并后台运行</span></span><br><span class="line">docker-compose down                         <span class="comment"># 停止并删除容器、网络、卷、镜像。</span></span><br><span class="line">docker-compose <span class="built_in">exec</span>  yml里面的服务<span class="built_in">id</span>                 <span class="comment"># 进入容器实例内部  </span></span><br><span class="line">docker-compose <span class="built_in">exec</span> docker-compose.yml  文件中写的服务<span class="built_in">id</span> /bin/bash</span><br><span class="line">docker-compose ps                      <span class="comment"># 展示当前docker-compose编排过的运行的所有容器</span></span><br><span class="line">docker-compose top                     <span class="comment"># 展示当前docker-compose编排过的容器进程</span></span><br><span class="line">docker-compose logs  yml里面的服务<span class="built_in">id</span>     <span class="comment"># 查看容器输出日志</span></span><br><span class="line">docker-compose config     <span class="comment"># 检查配置</span></span><br><span class="line">docker-compose config -q  <span class="comment"># 检查配置，有问题才有输出!!</span></span><br><span class="line">docker-compose restart   <span class="comment"># 重启服务</span></span><br><span class="line">docker-compose start     <span class="comment"># 启动服务</span></span><br><span class="line">docker-compose stop      <span class="comment"># 停止服务</span></span><br></pre></td></tr></table></figure><h4 id="使用-Compose"><a href="#使用-Compose" class="headerlink" title="使用 Compose"></a>使用 Compose</h4><h5 id="1-编写-docker-compose-yml-文件"><a href="#1-编写-docker-compose-yml-文件" class="headerlink" title="1.编写 docker-compose.yml 文件"></a>1.编写 docker-compose.yml 文件</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">    <span class="attr">microService:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zzyy_docker:1.6</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ms01</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;6001:6001&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/app/microService:/data</span></span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">atguigu_net</span> </span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6.0.8</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/app/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/app/redis/data:/data</span></span><br><span class="line">    <span class="attr">networks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line"><span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">        <span class="attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="string">&#x27;no&#x27;</span></span><br><span class="line">        <span class="attr">MYSQL_DATABASE:</span> <span class="string">&#x27;db2021&#x27;</span></span><br><span class="line">        <span class="attr">MYSQL_USER:</span> <span class="string">&#x27;zzyy&#x27;</span></span><br><span class="line">        <span class="attr">MYSQL_PASSWORD:</span> <span class="string">&#x27;zzyy123&#x27;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/app/mysql/db:/var/lib/mysql</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/app/mysql/conf/my.cnf:/etc/my.cnf</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/app/mysql/init:/docker-entrypoint-initdb.d222</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">atguigu_net</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--default-authenticationplugin=mysql_native_password</span> <span class="comment">#解决外部无法访问</span></span><br><span class="line"><span class="attr">networks:</span> </span><br><span class="line">    <span class="attr">atguigu_net:</span></span><br></pre></td></tr></table></figure><p>编写 Dockerfile</p><p>构建镜像<br>• docker build -t zzyy_docker:1.6 .</p><h5 id="执行-docker-compose-up-或者-执行-docker-compose-up-d"><a href="#执行-docker-compose-up-或者-执行-docker-compose-up-d" class="headerlink" title="执行 docker-compose up 或者 执行 docker-compose up -d"></a>执行 docker-compose up 或者 执行 docker-compose up -d</h5><p>进入 mysql 容器实例并新建库 db2021+新建表 t_user</p><h3 id="（七）Docker-轻量级可视化工具-Portainer"><a href="#（七）Docker-轻量级可视化工具-Portainer" class="headerlink" title="（七）Docker 轻量级可视化工具 Portainer"></a>（七）Docker 轻量级可视化工具 Portainer</h3><p>Portainer 是一款轻量级的应用，它提供了图形化界面，用于方便地管理 Docker 环境，包括单机环境和集群环境。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h5><p>• <a href="https://www.portainer.io/">https://www.portainer.io/</a><br>• <a href="https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux">https://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux</a></p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>docker 命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure><p>win</p><p>First, create the volume that Portainer Server will use to store its database. Using PowerShell:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer</span><br><span class="line">docker volume create portainer_data</span><br></pre></td></tr></table></figure><p>Then, download and install the Portainer Server container:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock --restart=always --name prtainer portainer/portainer</span><br></pre></td></tr></table></figure><p>—restart=always表示docker重启之后，此容器也随之重启，可持续监控</p><h5 id="第一次登录需创建-admin，访问地址：xxx-xxx-xxx-xxx-9000"><a href="#第一次登录需创建-admin，访问地址：xxx-xxx-xxx-xxx-9000" class="headerlink" title="第一次登录需创建 admin，访问地址：xxx.xxx.xxx.xxx:9000"></a>第一次登录需创建 admin，访问地址：xxx.xxx.xxx.xxx:9000</h5><p>用户名，直接用默认 admin 密码记得 8 位，随便你写</p><p>设置 admin 用户和密码后首次登陆</p><p>选择 local 选项卡后本地 docker 详细信息展示</p><h3 id="（八）Docker-容器监控之-CAdvisor-InfluxDB-Granfana"><a href="#（八）Docker-容器监控之-CAdvisor-InfluxDB-Granfana" class="headerlink" title="（八）Docker 容器监控之 CAdvisor+InfluxDB+Granfana"></a>（八）Docker 容器监控之 CAdvisor+InfluxDB+Granfana</h3><h5 id="docker-stats-命令的结果"><a href="#docker-stats-命令的结果" class="headerlink" title="docker stats 命令的结果"></a>docker stats 命令的结果</h5><p><img src="image-20221003140950045.png" alt="image-20221003140950045"></p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><p>通过 docker stats 命令可以很方便的看到当前宿主机上所有容器的 CPU,内存以及网络流量等数据，一般小公司够用了。。。。<br>但是，docker stats 统计结果只能是当前宿主机的全部容器，数据资料是实时的，没有地方存储、没有健康指标过线预警等功能</p><p><strong>CAdvisor 监控收集+InfluxDB 存储数据+Granfana 展示图表</strong></p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>compose 容器编排，一套带走</p><h5 id="新建目录"><a href="#新建目录" class="headerlink" title="新建目录"></a>新建目录</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mydocker/cig</span><br><span class="line">cd  /mydocker/cig</span><br></pre></td></tr></table></figure><h5 id="新建-3-件套组合的-docker-compose-yml"><a href="#新建-3-件套组合的-docker-compose-yml" class="headerlink" title="新建 3 件套组合的 docker-compose.yml"></a>新建 3 件套组合的 docker-compose.yml</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.1&quot;</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">grafana_data:</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attr">services:</span> </span><br><span class="line"><span class="attr">influxdb:</span> </span><br><span class="line"><span class="attr">image:</span> <span class="string">tutum/influxdb:0.9</span> </span><br><span class="line"><span class="attr">container_name:</span> <span class="string">ms01</span> </span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">environment:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">PRE_CREATE_DB=cadvisor</span></span><br><span class="line"><span class="attr">ports:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;8083:8083&quot;</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;8086:8086&quot;</span> </span><br><span class="line"><span class="attr">volumes:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">./data/influxdb:/data</span></span><br><span class="line"><span class="attr">cadvisor:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">google/cadvisor</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">influxdb:influxsrv</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">-storage_driver=influxdb</span> <span class="string">-storage_driver_db=cadvisor</span> <span class="string">-storage_driver_host=influxsrv:8086</span></span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line"><span class="attr">volumes:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">/:/rootfs:ro</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">/var/run:/var/run:rw</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">/sys:/sys:ro</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">/var/lib/docker/:/var/lib/docker:ro</span></span><br><span class="line"><span class="attr">grafana:</span></span><br><span class="line"><span class="attr">user:</span> <span class="string">&quot;104&quot;</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">grafana/grafana</span></span><br><span class="line"><span class="attr">user:</span> <span class="string">&quot;104&quot;</span></span><br><span class="line"><span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">influxdb:influxsrv</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">grafana_data:/var/lib/grafana</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">HTTP_USER=admin</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">HTTP_PASS=admin</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">INFLUXDB_HOST=influxsrv</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">INFLUXDB_PORT=8086</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">INFLUXDB_NAME=cadvisor</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">INFLUXDB_USER=root</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">INFLUXDB_PASS=root</span></span><br></pre></td></tr></table></figure><p>检查配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose config -q</span><br></pre></td></tr></table></figure><p>启动docker-compose文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line">#docker compose up -d</span><br></pre></td></tr></table></figure><h4 id="测试和使用"><a href="#测试和使用" class="headerlink" title="测试和使用"></a>测试和使用</h4><p>浏览 cAdvisor 收集服务，<a href="http://ip:8080/">http://ip:8080/</a></p><p>浏览 influxdb 存储服务，<a href="http://ip:8083/">http://ip:8083/</a></p><p>浏览 grafana 展现服务，<a href="http://ip:3000，默认账号密码都是admin">http://ip:3000，默认账号密码都是admin</a></p><h4 id="配置grafana-展现服务"><a href="#配置grafana-展现服务" class="headerlink" title="配置grafana 展现服务"></a>配置grafana 展现服务</h4><p>配置数据源</p><p><img src="image-20221003163416107.png" alt="image-20221003163416107"></p><p>选择 influxdb 数据源</p><p><img src="image-20221003163422531.png" alt="image-20221003163422531"></p><p>配置细节</p><p><img src="image-20221003163431635.png" alt="image-20221003163431635"></p><p><img src="image-20221003163437454.png" alt="image-20221003163437454"></p><p><img src="image-20221003163441615.png" alt="image-20221003163441615"></p><p>配置面板 panel</p><p><img src="image-20221003163448086.png" alt="image-20221003163448086"></p><p><img src="image-20221003163453277.png" alt="image-20221003163453277"></p><p><img src="image-20221003163456985.png" alt="image-20221003163456985"></p><p><img src="image-20221003163500586.png" alt="image-20221003163500586"></p><p><img src="image-20221003163505118.png" alt="image-20221003163505118"></p><p><img src="image-20221003163508897.png" alt="image-20221003163508897"></p><p>到这里 cAdvisor+InfluxDB+Grafana 容器监控系统就部署完成了</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> redis </tag>
            
            <tag> mysql </tag>
            
            <tag> dockerfile </tag>
            
            <tag> 容器编排 </tag>
            
            <tag> 可视化 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己的docker笔记基础</title>
      <link href="/posts/19b4cc0f/"/>
      <url>/posts/19b4cc0f/</url>
      
        <content type="html"><![CDATA[<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h4><p><a href="https://www.docker.com/">Home - Docker</a></p><h4 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h4><p><a href="https://www.runoob.com/docker/windows-docker-install.html">Windows Docker 安装 | 菜鸟教程 (runoob.com)</a></p><h4 id="centos安装"><a href="#centos安装" class="headerlink" title="centos安装"></a>centos安装</h4><p><a href="https://www.runoob.com/docker/centos-docker-install.html">CentOS Docker 安装 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#旧机器 Uninstall old versions</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest </span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">              </span><br><span class="line"><span class="comment">#新机器 Set up the repository</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"><span class="comment">#yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#重建yum缓冲</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 DOCKER CE</span></span><br><span class="line">yum -y install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动 docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">docker version</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载</span></span><br><span class="line">systemctl stop docker</span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h4 id="ubuntu安装"><a href="#ubuntu安装" class="headerlink" title="ubuntu安装"></a>ubuntu安装</h4><p><a href="https://jinianyoushang.github.io/posts/3756cf19/">最详细的ubuntu安装docker教程 | xd’s blog (jinianyoushang.github.io)</a></p><h4 id="设置镜像加速"><a href="#设置镜像加速" class="headerlink" title="设置镜像加速"></a>设置镜像加速</h4><h5 id="centos-ubuntu"><a href="#centos-ubuntu" class="headerlink" title="centos/ubuntu"></a>centos/ubuntu</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">我自己的网址 https://******.mirror.aliyuncs.com</span></span><br><span class="line"></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://******.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h5 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h5><p>针对安装了Docker Toolbox的用户，您可以参考以下配置步骤：</p><p>创建一台安装有Docker环境的Linux虚拟机，指定机器名称为default，同时配置Docker加速器地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --engine-registry-mirror=https://******.mirror.aliyuncs.com -d virtualbox default</span><br></pre></td></tr></table></figure><p>查看机器的环境配置，并配置到本地，并通过Docker客户端访问Docker服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine env defaulteval &quot;$(docker-machine env default)&quot;docker info</span><br></pre></td></tr></table></figure><p>针对安装了Docker for Windows的用户，您可以参考以下配置步骤：</p><p>在系统右下角托盘图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Docker Daemon。编辑窗口内的JSON串，填写下方加速器地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://******.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑完成后点击 Apply 保存按钮，等待Docker重启并应用配置的镜像加速器。</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>Docker for Windows 和 Docker Toolbox互不兼容，如果同时安装两者的话，需要使用hyperv的参数启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create --engine-registry-mirror=https://******.mirror.aliyuncs.com -d hyperv default</span><br></pre></td></tr></table></figure><p>Docker for Windows 有两种运行模式，一种运行Windows相关容器，一种运行传统的Linux容器。同一时间只能选择一种模式运行。</p><h3 id="WSL安装"><a href="#WSL安装" class="headerlink" title="WSL安装"></a>WSL安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#安装</span><br><span class="line">wsl --install</span><br><span class="line">#关闭wsl</span><br><span class="line">wsl --shutdown</span><br><span class="line"></span><br><span class="line">#检查正在运行的 WSL 版本</span><br><span class="line">wsl -l -v</span><br><span class="line">#将版本从 WSL 1 升级到 WSL 2</span><br><span class="line">wsl --install</span><br><span class="line">#令可用于从 WSL 2 降级到 WSL 1，或将以前安装的 Linux 发行版从 WSL 1 更新到 WSL 2。</span><br><span class="line">wsl --set-version</span><br></pre></td></tr></table></figure><h3 id="（一）Docker-常用命令"><a href="#（一）Docker-常用命令" class="headerlink" title="（一）Docker 常用命令"></a>（一）Docker 常用命令</h3><h5 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">• 启动 docker： systemctl start docker</span><br><span class="line">• 停止 docker： systemctl stop docker</span><br><span class="line">• 重启 docker： systemctl restart docker</span><br><span class="line">• 查看 docker 状态： systemctl status docker</span><br><span class="line">• 开机启动： systemctl enable docker</span><br><span class="line">• 查看 docker 概要信息： docker info</span><br><span class="line">• 查看 docker 总体帮助文档： docker --help</span><br><span class="line">• 查看 docker 命令帮助文档： docker 具体命令 --help</span><br><span class="line">docker stats #查看容器状态</span><br></pre></td></tr></table></figure><h5 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出本地主机上的镜像</span></span><br><span class="line">docker images</span><br><span class="line">OPTIONS 说明：</span><br><span class="line">• -a :列出本地所有的镜像（含历史映像层）</span><br><span class="line">• -q :只显示镜像 ID。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">搜索镜像</span></span><br><span class="line">docker search hello-world</span><br><span class="line">docker search hello-world --limit 5  #限制显示数量</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull hello-world</span><br><span class="line">docker pull redis:6.0.8 #可以指定版本号</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行</span></span><br><span class="line">docker run hello-world</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看镜像/容器/数据卷所占的空间</span></span><br><span class="line">docker system df </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">镜像传输</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将镜像保存成压缩包</span></span><br><span class="line">docker save -o abc.tar guignginx:v1.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">别的机器加载这个镜像</span></span><br><span class="line">docker load -i abc.tar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除某个镜像</span></span><br><span class="line">docker rmi 某个 XXX 镜像名字 ID</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">强制删除</span></span><br><span class="line">docker rmi -f 镜像 ID </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除多个</span></span><br><span class="line">docker rmi -f 镜像名 1:TAG 镜像名 2:TAG</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除全部</span></span><br><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><h5 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新建+启动容器</span></span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">OPTIONS 说明</span></span><br><span class="line">--name=&quot;容器新名字&quot; 为容器指定一个名称；</span><br><span class="line">-d: 后台运行容器并返回容器 ID，也即启动守护式容器(后台运行)；</span><br><span class="line">-i：以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-t：为容器重新分配一个伪输入终端，通常与</span><br><span class="line">-i 同时使用；也即启动交互式容器(前台有伪终端，等待交互)；</span><br><span class="line">-P: 随机端口映射，大写 P</span><br><span class="line">-p: 指定端口映射，小写 p    本机端口:容器端口</span><br><span class="line">--restart=always  #表示docker重启之后，此容器也随之重启，可持续监控</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用镜像 centos:latest 以交互模式启动一个容器,在容器内执行/bin/bash 命令。</span></span><br><span class="line">docker run -it ubuntu /bin/bash </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出当前所有正在运行的容器</span></span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">OPTIONS 说明</span></span><br><span class="line">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line">-n：显示最近 n 个创建的容器。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">退出容器 两种退出方式</span></span><br><span class="line">• exit #run 进去容器，exit 退出，容器停止</span><br><span class="line">• ctrl+p+q # run 进去容器，ctrl+p+q 退出，容器不停止</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动已停止运行的容器</span></span><br><span class="line">docker start 容器 ID 或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重启容器</span></span><br><span class="line">docker restart 容器 ID 或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop 容器 ID 或者容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">强制停止容器</span></span><br><span class="line">docker kill 容器 ID 或容器名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看停止的容器</span> </span><br><span class="line">docker ps -a  #列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">docker ps -l #显示最近创建的容器。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除已停止的容器</span></span><br><span class="line">docker rm 容器 ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有容器内ip</span></span><br><span class="line">docker inspect --format=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; $(docker ps -a -q)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止所有容器命令：</span></span><br><span class="line">sudo docker stop $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动所有容器命令：</span></span><br><span class="line">sudo docker start $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">一次性删除多个容器实例 危险！！</span></span><br><span class="line">docker rm -f $(docker ps -a -q)</span><br><span class="line">docker ps -a -q | xargs docker rm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器日志</span></span><br><span class="line">docker logs 容器 ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器内运行的进程</span></span><br><span class="line">docker top 容器 ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看容器内部细节</span></span><br><span class="line">docker inspect 容器 ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入正在运行的容器并以命令行交互 不会停止进程!!!</span></span><br><span class="line">docker exec -it 容器ID bash</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新进入 会停止进程 尽量使用<span class="built_in">exec</span></span></span><br><span class="line">docker attach 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从容器内拷贝文件到主机上</span></span><br><span class="line">docker cp 容器 ID:容器内路径 目的主机路径</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">从主机上拷贝文件到容器内</span></span><br><span class="line">docker cp 本地文件路径 ID全称:容器路径</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">导入和导出容器</span></span><br><span class="line">export 导出容器的内容留作为一个 tar 归档文件[对应 import 命令]</span><br><span class="line">import 从 tar 包中的内容创建一个新的文件系统再导入为镜像[对应 export]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例</span></span><br><span class="line">docker export 容器ID &gt; 文件名.tar</span><br><span class="line">cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">忘了添加参数 --restart=always ,可以在后面增加</span></span><br><span class="line">docker container update --restart=always 容器名字</span><br></pre></td></tr></table></figure><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用镜像 centos:latest 以交互模式启动一个容器,在容器内执行/bin/bash 命令。</span></span><br><span class="line">docker run -it ubuntu /bin/bash </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用镜像 centos:latest 以后台模式启动一个容器</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后 docker ps -a 进行查看, 会发现容器已经退出</span></span><br><span class="line">docker run -d centos  #这个会自动退出</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后台守护式启动 redis</span></span><br><span class="line">docker run -d redis</span><br><span class="line">docker run -d -p 6379:6379 --name docker-redis redis</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动ubuntu，交互模式+后台守护 并端口映射 本地8001：容器内部80 随docker启动而启动  并进入命令行</span></span><br><span class="line">docker run --name ubuntu_lingsheng -itd -p 8002:80 --restart=always   ubuntu  /bin/bash </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入正在运行的容器并以命令行交互 不会停止进程!!!</span></span><br><span class="line">docker exec -it a054da0aef6f  bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。</span></span><br><span class="line">docker run --name nginx-test -p 8080:80 -d nginx</span><br></pre></td></tr></table></figure><h3 id="（二）Docker-制作镜像commit-操作案例"><a href="#（二）Docker-制作镜像commit-操作案例" class="headerlink" title="（二）Docker 制作镜像commit 操作案例"></a>（二）Docker 制作镜像commit 操作案例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker commit 提交容器副本使之成为一个新的镜像</span></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器 ID 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行ubuntu</span></span><br><span class="line">docker run -it  ubuntu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker 容器内执行上述两条命令： 安装vim</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get -y install vim</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建镜像 类似于继承扩展</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-m 信息 -a 作者 <span class="built_in">id</span> 64ab1e160dda</span></span><br><span class="line">docker commit -m &quot;add vim cmd&quot;  -a &quot;xd&quot; 64ab1e160dda myubuntu:1.0</span><br><span class="line">docker commit -m &quot;add ifconfig cmd&quot;  -a &quot;xd&quot; 16a5aea2318b myubuntu:1.1</span><br></pre></td></tr></table></figure><h3 id="（三）推送镜像到阿里云"><a href="#（三）推送镜像到阿里云" class="headerlink" title="（三）推送镜像到阿里云"></a>（三）推送镜像到阿里云</h3><h5 id="1-登录阿里云Docker-Registry"><a href="#1-登录阿里云Docker-Registry" class="headerlink" title="1. 登录阿里云Docker Registry"></a>1. 登录阿里云Docker Registry</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login --username=纪念忧伤1 registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure><p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p><p>您可以在访问凭证页面修改凭证密码。</p><h5 id="2-从Registry中拉取镜像"><a href="#2-从Registry中拉取镜像" class="headerlink" title="2. 从Registry中拉取镜像"></a>2. 从Registry中拉取镜像</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull registry.cn-hangzhou.aliyuncs.com/ubuntu111/myubuntu:[镜像版本号]</span><br></pre></td></tr></table></figure><h5 id="3-将镜像推送到Registry"><a href="#3-将镜像推送到Registry" class="headerlink" title="3. 将镜像推送到Registry"></a>3. 将镜像推送到Registry</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker login --username=纪念忧伤1 registry.cn-hangzhou.aliyuncs.com</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/ubuntu111/myubuntu:[镜像版本号]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker push registry.cn-hangzhou.aliyuncs.com/ubuntu111/myubuntu:[镜像版本号]</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f98c36a1fefe</span><br><span class="line">docker tag f98c36a1fefe registry.cn-hangzhou.aliyuncs.com/ubuntu111/myubuntu:1.0</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/ubuntu111/myubuntu:1.0</span><br></pre></td></tr></table></figure><p>请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。</p><h5 id="4-选择合适的镜像仓库地址"><a href="#4-选择合适的镜像仓库地址" class="headerlink" title="4. 选择合适的镜像仓库地址"></a>4. 选择合适的镜像仓库地址</h5><p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p><p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录。</p><h5 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h5><p>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker imagesREPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZEregistry.aliyuncs.com/acs/agent                                    0.7-dfb6816         37bb9c63c8b2        7 days ago          37.89 MB</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker tag 37bb9c63c8b2 registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816</span></span><br></pre></td></tr></table></figure><p>使用 “docker push” 命令将该镜像推送至远程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker push registry-vpc.cn-hangzhou.aliyuncs.com/acs/agent:0.7-dfb6816</span></span><br></pre></td></tr></table></figure><h3 id="（四）本地镜像库"><a href="#（四）本地镜像库" class="headerlink" title="（四）本地镜像库"></a>（四）本地镜像库</h3><h5 id="运行私有库-Registry，相当于本地有个私有-Docker-hub"><a href="#运行私有库-Registry，相当于本地有个私有-Docker-hub" class="headerlink" title="运行私有库 Registry，相当于本地有个私有 Docker hub"></a>运行私有库 Registry，相当于本地有个私有 Docker hub</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry --privileged=<span class="literal">true</span>  registry</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">cf29cd04d793</span></span><br></pre></td></tr></table></figure><h5 id="更新Ubuntu"><a href="#更新Ubuntu" class="headerlink" title="更新Ubuntu"></a>更新Ubuntu</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装ifconfig</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install net-tools</span><br></pre></td></tr></table></figure><h5 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m &quot;add ifconfig cmd&quot;  -a &quot;xd&quot; 16a5aea2318b myubuntu:1.1</span><br></pre></td></tr></table></figure><h5 id="curl-验证私服库上有什么镜像"><a href="#curl-验证私服库上有什么镜像" class="headerlink" title="curl 验证私服库上有什么镜像"></a>curl 验证私服库上有什么镜像</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://192.168.113.132:5000/v2/_catalog</span><br></pre></td></tr></table></figure><h5 id="将新镜像-zzyyubuntu-1-2-修改符合私服规范的-Tag"><a href="#将新镜像-zzyyubuntu-1-2-修改符合私服规范的-Tag" class="headerlink" title="将新镜像 zzyyubuntu:1.2 修改符合私服规范的 Tag"></a>将新镜像 zzyyubuntu:1.2 修改符合私服规范的 Tag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag myubuntu:1.1 192.168.113.132:5000/myubuntu:1.1</span><br></pre></td></tr></table></figure><h5 id="修改配置文件使之支持-http"><a href="#修改配置文件使之支持-http" class="headerlink" title="修改配置文件使之支持 http"></a>修改配置文件使之支持 http</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://aa25jngu.mirror.aliyuncs.com&quot;],</span><br><span class="line">&quot;insecure-registries&quot;: [&quot;192.168.113.132:5000&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完后如果不生效，建议重启 docker,然后重新运行仓库</p><h5 id="push-推送到私服库"><a href="#push-推送到私服库" class="headerlink" title="push 推送到私服库"></a>push 推送到私服库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.113.132:5000/myubuntu:1.1</span><br></pre></td></tr></table></figure><h5 id="pull-到本地并运行"><a href="#pull-到本地并运行" class="headerlink" title="pull 到本地并运行"></a>pull 到本地并运行</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull  192.168.113.132:5000/myubuntu:1.1</span><br></pre></td></tr></table></figure><h3 id="五-Docker-容器数据卷"><a href="#五-Docker-容器数据卷" class="headerlink" title="(五) Docker 容器数据卷"></a>(五) Docker 容器数据卷</h3><p>卷就是目录或文件，存在于一个或多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System 提供一些用于持续存储或共享数据的特性：卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此 Docker 不会在容器删除时删除其挂载的数据卷</p><h5 id="运行一个带有容器卷存储功能的容器实例-v"><a href="#运行一个带有容器卷存储功能的容器实例-v" class="headerlink" title="运行一个带有容器卷存储功能的容器实例 -v"></a>运行一个带有容器卷存储功能的容器实例 -v</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加读写规则</span></span><br><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:rw 镜像名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">容器实例内部被限制，只能读取不能写</span></span><br><span class="line">docker run -it --privileged=true -v /宿主机绝对路径目录:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure><p>文件夹<strong>两边是双向同步的</strong>，可以多个文件夹同步</p><p>容器停止后，重启也会同步</p><h5 id="容器-2-继承容器-1-的卷规则-—volumes-from"><a href="#容器-2-继承容器-1-的卷规则-—volumes-from" class="headerlink" title="容器 2 继承容器 1 的卷规则 —volumes-from"></a>容器 2 继承容器 1 的卷规则 —volumes-from</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=true --volumes-from 父类 --name u2 ubuntu</span><br></pre></td></tr></table></figure><h5 id="坑：容器卷记得加入"><a href="#坑：容器卷记得加入" class="headerlink" title="坑：容器卷记得加入"></a>坑：容器卷记得加入</h5><p>Docker 挂载主机目录访问如果出现cannot open directory .: Permission denied</p><p>解决办法：在挂载目录后多加一个—privileged=true 参数即可</p><h4 id="六-docker常规软件安装"><a href="#六-docker常规软件安装" class="headerlink" title="(六) docker常规软件安装"></a>(六) docker常规软件安装</h4><p>docker run之后要docker ps看看有没有启动</p><h5 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#tomcat</span><br><span class="line">docker pull tomcat</span><br><span class="line">docker run -it -p 8080:8080 tomcat</span><br><span class="line">docker run -d -p 8080:8080 tomcat</span><br><span class="line"></span><br><span class="line">#之后进入tomcat 将webapps.dist 改成webapps</span><br><span class="line">docker exec -it 7a7673026676  bash</span><br><span class="line">rm webapps -r</span><br><span class="line">mv webapps.dist/ webapps</span><br><span class="line"></span><br><span class="line">#免修改版说明</span><br><span class="line">docker pull billygoo/tomcat8-jdk8</span><br><span class="line">docker run -d -p 8080:8080 --name mytomcat8 billygoo/tomcat8-jdk8</span><br></pre></td></tr></table></figure><h5 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">简单版 没有用</span></span><br><span class="line">docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">docker exec -it 容器 ID /bin/bash</span><br><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">实战版启动</span></span><br><span class="line">docker run -d -p 3306:3306 --privileged=true \</span><br><span class="line">-v /zzyyuse/mysql/log:/var/log/mysql \</span><br><span class="line">-v /zzyyuse/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /zzyyuse/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql5.7 mysql:5.7</span><br></pre></td></tr></table></figure><h6 id="默认字符集为latin1-解决中文乱码"><a href="#默认字符集为latin1-解决中文乱码" class="headerlink" title="默认字符集为latin1 解决中文乱码"></a>默认字符集为latin1 解决中文乱码</h6><blockquote><p>SHOW VARIABLES LIKE ‘character%’</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新建 my.cnf</span></span><br><span class="line">[client]</span><br><span class="line">default_character_set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">collation_server = utf8_general_ci</span><br><span class="line">character_set_server = utf8</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过容器卷同步给 mysql 容器实例</span></span><br><span class="line">cd /zzyyuse/mysql/conf/</span><br><span class="line">ls</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改为上面的</span></span><br><span class="line">vim my.cnf</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">重新启动 mysql 容器实例再重新进入并查看字符编码</span></span><br><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure><p>docker 安装完 MySQL 并 run 出容器后，建议请先修改完字符集编码后再新建 mysql 库-表-插数据</p><h5 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">入门版 不常用</span></span><br><span class="line">docker run -d -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h6 id="实战版启动"><a href="#实战版启动" class="headerlink" title="实战版启动"></a>实战版启动</h6><h1 id="建目录"><a href="#建目录" class="headerlink" title="建目录"></a>建目录</h1><p>mkdir -p /app/redis</p><h1 id="将一个-redis-conf-文件模板拷贝进-app-redis-目录下"><a href="#将一个-redis-conf-文件模板拷贝进-app-redis-目录下" class="headerlink" title="将一个 redis.conf 文件模板拷贝进/app/redis 目录下"></a>将一个 redis.conf 文件模板拷贝进/app/redis 目录下</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#/app/redis 目录下修改 redis.conf 文件</span><br><span class="line">3.1 开启 redis 验证 可选</span><br><span class="line">requirepass 123</span><br><span class="line"></span><br><span class="line">3.2 允许 redis 外地连接 必须</span><br><span class="line">注释掉 # bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">3.3daemonize no 必须</span><br><span class="line">将 daemonize yes 注释起来或者 daemonize no 设置，因为该配置和 docker run 中-d 参数冲突，会导致容器一直启动失败</span><br><span class="line"></span><br><span class="line">3.4开启 redis 数据持久化 </span><br><span class="line">appendonly yes 可选</span><br><span class="line"></span><br><span class="line">3.5关闭保护模式</span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><h6 id="使用-redis6-0-8-镜像创建容器-也叫运行镜像"><a href="#使用-redis6-0-8-镜像创建容器-也叫运行镜像" class="headerlink" title="使用 redis6.0.8 镜像创建容器(也叫运行镜像)"></a>使用 redis6.0.8 镜像创建容器(也叫运行镜像)</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name myr3 --privileged=true -v /app/redis/redis.conf:/etc/redis/redis.conf -v /app/redis/data:/data -d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>win</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name myredis1 --privileged=true -v D:/mydocker/redis/redis.conf:/etc/redis/redis.conf -v D:/mydocker/redis/data:/data -d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程 | 菜鸟教程 (runoob.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> redis </tag>
            
            <tag> mysql </tag>
            
            <tag> 镜像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置阿里云docker加速服务</title>
      <link href="/posts/4c1a7ee4/"/>
      <url>/posts/4c1a7ee4/</url>
      
        <content type="html"><![CDATA[<h1 id="配置阿里云docker加速服务"><a href="#配置阿里云docker加速服务" class="headerlink" title="配置阿里云docker加速服务"></a>配置阿里云docker加速服务</h1><p><strong>简介：</strong> 加速器推荐• 阿里云的加速器<a href="https://help.aliyun.com/document_detail/60750.html•">https://help.aliyun.com/document_detail/60750.html•</a> DaoCloud 加速器：<a href="https://www.daocloud.io/mirror#accelerator-doc1">https://www.daocloud.io/mirror#accelerator-doc1</a>. 安装／升级 Docker 客户端推荐安装 1.10.0 以上版本的 Docker 客户端，参考文档 docker-ce2. 配置镜像加速器直接登录阿里云 - 容器 Hub 服务控制台后，点击“镜像加速器”标签，也会出现相应信息。在出现的“容器镜像服务”页面，依次查找：镜像中心—-》镜像加速器，并点击，可以得到一个专属的镜像加速</p><h2 id="加速器推荐"><a href="#加速器推荐" class="headerlink" title="加速器推荐"></a>加速器推荐</h2><ul><li>阿里云的加速器<a href="https://links.jianshu.com/go?spm=a2c6h.12873639.article-detail.7.51082fb4TLZoQh&amp;to=https%3A%2F%2Fhelp.aliyun.com%2Fdocument_detail%2F60750.html">https://help.aliyun.com/document_detail/60750.html</a></li></ul><h2 id="1-安装／升级-Docker-客户端"><a href="#1-安装／升级-Docker-客户端" class="headerlink" title="1. 安装／升级 Docker 客户端"></a>1. 安装／升级 Docker 客户端</h2><p>推荐安装 1.10.0 以上版本的 Docker 客户端，参考文档 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fyq.aliyun.com%2Farticles%2F110806">docker-ce</a></p><h2 id="2-配置镜像加速器"><a href="#2-配置镜像加速器" class="headerlink" title="2. 配置镜像加速器"></a>2. 配置镜像加速器</h2><p>直接登录<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcr.console.aliyun.com%2F">阿里云 - 容器 Hub 服务控制台</a>后，点击“镜像加速器”标签，也会出现相应信息。</p><p>在出现的“容器镜像服务”页面，依次查找：镜像中心—-》镜像加速器，并点击，可以得到一个专属的镜像加速地址，类似于“<a href="https://links.jianshu.com/go?to=https%3A%2F%2F1234abcd.mirror.aliyuncs.com%2F">https://d4iq1rp9.mirror.aliyuncs.com</a>”。</p><p><img src="214d2b30d2cc42488f224e83b1bb2294.png" alt="image.png"></p><p>根据页面中的“操作文档”信息，对应系统类型，配置自己的 Docker 镜像加速器。</p><p>例如：CentOS系统</p><p>针对Docker客户端版本大于 1.10.0 的用户</p><p>您可以通过修改daemon配置文件 /etc/docker/daemon.json 来使用加速器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://xxxxxx.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>最后别忘记重新启动 docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="不需要登录账号（支持匿名pull）"><a href="#不需要登录账号（支持匿名pull）" class="headerlink" title="不需要登录账号（支持匿名pull）"></a>不需要登录账号（支持匿名pull）</h2><p>国内从 DockerHub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p><p>Docker 官方提供的中国镜像库：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fregistry.docker-cn.com">https://registry.docker-cn.com</a></p><p>七牛云加速器：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Freg-mirror.qiniu.com">https://reg-mirror.qiniu.com</a></p><p>对于使用 systemd 的系统(Ubuntu 16.04+、Debian 8+、CentOS 7+)，可以创建 /etc/docker/daemon.json 文件，并写入如下内容（如果文件不存在请新建该文件）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com/&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后别忘记重新启动 docker：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.aliyun.com/article/929177#:~:text=安装／升级 Docker 客户端推荐安装 1.10.0 以上版本的 Docker 客户端，参考文档,docker-ce2. 配置镜像加速器直接登录阿里云 - 容器 Hub 服务控制台后，点击“镜像加速器”标签，也会出现相应信息。 在出现的“容器镜像服务”页面，依次查找：镜像中心---》镜像加速器，并点击，可以得到一个专属的镜像加速">配置 docker 加速服务-阿里云开发者社区 (aliyun.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 镜像加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>word转换为pdf后图片失真的解决办法</title>
      <link href="/posts/2cd64dd6/"/>
      <url>/posts/2cd64dd6/</url>
      
        <content type="html"><![CDATA[<p>解决word转pdf图片失真的最终方案，并且有目录书签。</p><hr><h2 id="01-需要的软件"><a href="#01-需要的软件" class="headerlink" title="01 | 需要的软件"></a><strong>01 | 需要的软件</strong></h2><p>Adobe Acrobat Pro DC这里需要各位小伙伴自己上网找资源，下载安装之后会出现下面两个应用。</p><p><img src="v2-3b49e5157b4c1d7cef450754e2af64cf_1440w.webp" alt="img"></p><p>打开word之后，会发现在上方选项卡会出现Acrobat的插件。</p><p><img src="v2-318d024ab71fcd46ec9971095133710f_1440w.webp" alt="img"></p><p>如果没有出现Acrobat插件也没关系，可以按照以下步骤打开Acrobat插件：依次点击 文件-&gt;选项-&gt;加载项-&gt;管理COM加载新-&gt;转到-&gt;勾选“Acrobat PDFMaker Office COM Addin”-&gt;确定</p><p><img src="v2-f1691a8dbfcbe93979476d9b441c396f_1440w.webp" alt="img"></p><hr><h2 id="02-配置Acrobat-PDFMaker"><a href="#02-配置Acrobat-PDFMaker" class="headerlink" title="02 | 配置Acrobat PDFMaker"></a><strong>02 | 配置Acrobat PDFMaker</strong></h2><p>（1）点击word选项卡上的Acrobat插件，（2）点击“首选项”按钮，（3）点击“高级配置”按钮（4）点击左侧“图像”按钮</p><p>（5）将右侧所有选项全部选为“关”的状态（6）另存为“Press Quality(1).joboptions”文件，然后点击“确定”关闭窗口</p><p><img src="v2-710617e37e7c9841bf67e2b3d9dbb513_1440w.webp" alt="img"></p><p><img src="v2-7db59d50fc7f50a1127751c5857f6cd9_1440w.png" alt="img"></p><hr><h2 id="03-更改Acrobat-PDFMaker中的首选项"><a href="#03-更改Acrobat-PDFMaker中的首选项" class="headerlink" title="03| 更改Acrobat PDFMaker中的首选项"></a><strong>03| 更改Acrobat PDFMaker中的首选项</strong></h2><p>（1）点击word选项卡上的Acrobat插件，（2）点击“首选项”按钮，（3）点击“转换设置”，更改成刚才保存的“Press Quality(1)”，</p><p>（4）点击“确定”，关闭窗口</p><p><img src="v2-04bf6439998fcfb83bf1ea55115bf448_1440w.png" alt="img"></p><hr><h2 id="04-将word转换成pdf"><a href="#04-将word转换成pdf" class="headerlink" title="04| 将word转换成pdf"></a><strong>04| 将word转换成pdf</strong></h2><p>依次点击 文件-&gt;另存为Adobe PDF</p><p><img src="v2-e77c35afffdc611cb2931e314ae16485_1440w.png" alt="img"></p><p>下图（左）采用上述转换方法后的pdf，图（右）是采用普通的转换方法后的pdf，清晰度情况一眼便能看出，并且采用上述转换方法后的pdf<strong>也有目录</strong>。</p><h2 id="其他：图片设置"><a href="#其他：图片设置" class="headerlink" title="其他：图片设置"></a>其他：图片设置</h2><p>如果打印出来的pdf太大，可以使用下面的方法</p><p>这样可以图片保证质量，又兼顾体积不会太大。但是实际测试没有无压缩的图片清晰度高。</p><p>另一个知乎回答看的：将图像的输出调一下，①彩色图像：缩减像素采样：平均缩减像素采样600dpi，若…900dpi JEPG 最大化；②灰度图像：双立方缩减像素采样300dip，若…450dpi， JEPG 最大化；③黑白图像：双立方缩减像素采样1200dip，若…1800dpi。既可以保证质量，又兼顾体积不会太大</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/106382349">word转换为pdf后图片失真的解决办法（全网首发） - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> word </tag>
            
            <tag> pdf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker容器启动后修改或添加端口</title>
      <link href="/posts/5fdb66a5/"/>
      <url>/posts/5fdb66a5/</url>
      
        <content type="html"><![CDATA[<p>docker<a href="https://cloud.tencent.com/product/tke?from_column=20065&amp;from=20065">容器</a>启动后怎么修改端口映射？在docker run创建并运行容器的时候，可以通过-p指定端口映射规则。但是，也会遇到刚开始忘记设置端口映射或者设置错了需要修改的情况。当docker start运行容器后，并没有提供一个-p选项或设置，让你修改指定端口映射规则。</p><p>通常间接的办法是，保存镜像，再创建一个新的容器，在创建时指定新的端口映射。</p><h2 id="方法一：删除原有容器，重新建新容器"><a href="#方法一：删除原有容器，重新建新容器" class="headerlink" title="方法一：删除原有容器，重新建新容器"></a>方法一：删除原有容器，重新建新容器</h2><p>这个解决方案最为简单，把原来的容器删掉，重新建一个。当然这次不要忘记加上端口映射。优点是简单快捷，在测试环境使用较多。缺点是如果是<a href="https://cloud.tencent.com/solution/database?from_column=20065&amp;from=20065">数据库</a>镜像，那重新建一个又要重新配置一次，就比较麻烦了。</p><h2 id="方法二：利用docker-commit新构镜像"><a href="#方法二：利用docker-commit新构镜像" class="headerlink" title="方法二：利用docker commit新构镜像"></a>方法二：利用docker commit新构镜像</h2><p>docker commit：把一个容器的文件改动和配置信息commit到一个新的镜像。这个在测试的时候会非常有用，把容器所有的文件改动和配置信息导入成一个新的docker镜像，然后用这个新的镜像重起一个容器，这对之前的容器不会有任何影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stop A</span><br><span class="line">docker commit A imageA <span class="comment">#将容器commit提交成为一个镜像</span></span><br><span class="line">docker <span class="built_in">rm</span> A <span class="comment">#删除原镜像</span></span><br><span class="line">docker run -d -p 80:80 --name A imageA <span class="comment">#启动新镜像</span></span><br></pre></td></tr></table></figure><p>这种方式的优点是不会影响统一<a href="https://cloud.tencent.com/product/cdh?from_column=20065&amp;from=20065">宿主机</a>上的其他容器。</p><p>需要生成新的镜像和容器，管理镜像和容器的时间成本会上升</p><h2 id="方法三：修改文件端口，重启docker服务（推荐）"><a href="#方法三：修改文件端口，重启docker服务（推荐）" class="headerlink" title="方法三：修改文件端口，重启docker服务（推荐）"></a>方法三：修改文件端口，重启docker服务（推荐）</h2><h3 id="1-停止docker-一定要先停止dokcer，不然直接修改配置文件不会生效"><a href="#1-停止docker-一定要先停止dokcer，不然直接修改配置文件不会生效" class="headerlink" title="1.停止docker(一定要先停止dokcer，不然直接修改配置文件不会生效)"></a>1.停止docker(<code>一定</code>要先停止dokcer，不然直接修改配置文件<code>不会生效</code>)</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure><h3 id="2-修改这个容器的hostconfig-json文件中的端口"><a href="#2-修改这个容器的hostconfig-json文件中的端口" class="headerlink" title="2.修改这个容器的hostconfig.json文件中的端口"></a>2.修改这个容器的hostconfig.json文件中的端口</h3><p>使用<code>docker ps -aq</code>可以得到容器ID并记录</p><p>进入容器配置目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/docker/containers</span><br></pre></td></tr></table></figure><p>之后进入[hash_of_the_container]</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim hostconfig.json</span><br><span class="line"><span class="comment">#或者直接下面的</span></span><br><span class="line">vim /var/lib/docker/containers/[hash_of_the_container]/hostconfig.json</span><br></pre></td></tr></table></figure><ul><li>输入 / ，搜索映射之前的端口（9999）</li><li>修改端口值就行了</li><li>修改完后 :wq 退出并保存此文件</li></ul><p>在 <code>hostconfig.json</code> 里有 “PortBindings”:{} 这个配置项，可以改成 “PortBindings”:{“80/tcp”:[{“HostIp”:”0.0.0.0”,”HostPort”:”8080”}]}</p><p>其中”80/tcp”指的是容器里面的端口，HostIp和HostPort指的是本机ip和端口</p><p>例 <code>hostconfig.json</code> 已删除不相关配置, 只保留格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;PortBindings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;5700/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10086&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;6700/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6700&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;9000/tcp&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;HostIp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;HostPort&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8080&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-重启-docker服务"><a href="#4-重启-docker服务" class="headerlink" title="4.重启 docker服务"></a>4.重启 docker服务</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="5-查看配置项已经修改成功"><a href="#5-查看配置项已经修改成功" class="headerlink" title="5.查看配置项已经修改成功"></a>5.查看配置项已经修改成功</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect  CONTAINER ID</span><br></pre></td></tr></table></figure><p><img src="h3t6z66nrt.png" alt="这里是引用"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> 追加端口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu修改镜像源</title>
      <link href="/posts/39a0e8ef/"/>
      <url>/posts/39a0e8ef/</url>
      
        <content type="html"><![CDATA[<p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p><a href="https://blog.csdn.net/qq_14931165/article/details/126863871">Ubuntu修改源镜像方法（22.04也能用）附带常用源镜像地址-CSDN博客</a></p><p><a href="https://mirrors.bfsu.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 北京外国语大学开源软件镜像站 | BFSU Open Source Mirror</a></p><h2 id="查看ubuntu版本号"><a href="#查看ubuntu版本号" class="headerlink" title="查看ubuntu版本号"></a>查看ubuntu版本号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure><h2 id="1-简单方法"><a href="#1-简单方法" class="headerlink" title="1.简单方法"></a>1.简单方法</h2><p>使用sed命令进行替换。</p><p>这里是北外的源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -i s@/archive.ubuntu.com/@/mirrors.bfsu.edu.cn/@g /etc/apt/sources.list</span><br><span class="line">sed -i s@/security.ubuntu.com/@/mirrors.bfsu.edu.cn/@g /etc/apt/sources.list</span><br><span class="line">apt-get clean</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>这里是阿里云的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="line">sed -i s@/security.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="line">apt-get clean</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><h2 id="2-手动修改"><a href="#2-手动修改" class="headerlink" title="2.手动修改"></a>2.手动修改</h2><p>Ubuntu 的软件源配置文件是 <code>/etc/apt/sources.list</code>。将系统自带的该文件做个备份，将该文件替换为下面内容，即可使用选择的软件源镜像。</p><p>这里以ubuntu22.04为例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.bfsu.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.bfsu.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.bfsu.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.bfsu.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.bfsu.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.bfsu.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.bfsu.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># # deb-src https://mirrors.bfsu.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure><p>其余可以查看来修改</p><p><a href="https://mirrors.bfsu.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 北京外国语大学开源软件镜像站 | BFSU Open Source Mirror</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 镜像源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker在各个平台的安装</title>
      <link href="/posts/11c41fc3/"/>
      <url>/posts/11c41fc3/</url>
      
        <content type="html"><![CDATA[<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h4><p><a href="https://www.docker.com/">Home - Docker</a></p><h4 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h4><p><a href="https://www.runoob.com/docker/windows-docker-install.html">Windows Docker 安装 | 菜鸟教程 (runoob.com)</a></p><h4 id="centos安装"><a href="#centos安装" class="headerlink" title="centos安装"></a>centos安装</h4><p><a href="https://www.runoob.com/docker/centos-docker-install.html">CentOS Docker 安装 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#旧机器 Uninstall old versions</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest </span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">              </span><br><span class="line"><span class="comment">#新机器 Set up the repository</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"><span class="comment">#yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#重建yum缓冲</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 DOCKER CE</span></span><br><span class="line">yum -y install docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动 docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">docker version</span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载</span></span><br><span class="line">systemctl stop docker</span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h4 id="ubuntu安装"><a href="#ubuntu安装" class="headerlink" title="ubuntu安装"></a>ubuntu安装</h4><p>本文以Ubuntu20.05系统为例安装docker，<a href="https://link.zhihu.com/?target=https%3A//ubuntu.com/download">Ubuntu官方下载地址</a>。</p><p>检查卸载老版本docker</p><p>ubuntu下自带了docker的库，不需要添加新的源。<br>但是ubuntu自带的docker版本太低，需要先卸载旧的再安装新的。</p><p>注：docker的旧版本不一定被称为docker，<a href="https://link.zhihu.com/?target=http%3A//docker.io">http://docker.io</a> 或 docker-engine也有可能，所以我们卸载的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><p>如果不能正常卸载，出现如下情况，显示无权限时，需要添加管理员权限才可进行卸载：</p><p><img src="v2-90241efe0f829a37c1db3fad3349c849_720w.webp" alt="img"></p><p>我们就需要使用<code>sudo apt-get remove docker docker-engine docker.io containerd runc</code>命令使用root权限来进行卸载。</p><p>安装步骤</p><h3 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h3><p>在终端中执行以下命令来更新Ubuntu软件包列表和已安装软件的版本:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装docker依赖"><a href="#安装docker依赖" class="headerlink" title="安装docker依赖"></a>安装docker依赖</h3><p>Docker在Ubuntu上依赖一些软件包。执行以下命令来安装这些依赖:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><h3 id="添加Docker官方GPG密钥"><a href="#添加Docker官方GPG密钥" class="headerlink" title="添加Docker官方GPG密钥"></a>添加Docker官方GPG密钥</h3><p>执行以下命令来添加Docker官方的GPG密钥:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="v2-0bd38706177023cfe438258e1009d83a_720w.webp" alt="img"></p><h3 id="添加Docker软件源"><a href="#添加Docker软件源" class="headerlink" title="添加Docker软件源"></a>添加Docker软件源</h3><p>执行以下命令来添加Docker的软件源:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p><strong>注：该命令需要使用root权限</strong></p><p><img src="v2-cbcdc65224f69f4e6c3c5ee5ac696012_720w.webp" alt="img"></p><h3 id="安装docker-1"><a href="#安装docker-1" class="headerlink" title="安装docker"></a>安装docker</h3><p>执行以下命令来安装Docker:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h3 id="配置用户组（可选）"><a href="#配置用户组（可选）" class="headerlink" title="配置用户组（可选）"></a>配置用户组（可选）</h3><p>默认情况下，只有root用户和docker组的用户才能运行Docker命令。我们可以将当前用户添加到docker组，以避免每次使用Docker时都需要使用sudo。命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p><strong>注：重新登录才能使更改生效。</strong></p><p>运行docker</p><p>我们可以通过启动<code>docker</code>来验证我们是否成功安装。命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a><strong>安装工具</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a><strong>重启docker</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a><strong>验证是否成功</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>运行命令后，结果如下：</p><p><img src="v2-97314d2165190bb4a6926facc7e77eeb_720w.webp" alt="img"></p><p>因为我们之前没有拉取过<code>hello-world</code>，所以运行命令后会出现本地没有该镜像，并且会自动拉取的操作。</p><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a><strong>查看版本</strong></h3><p>我们可以通过下面的命令来查看<code>docker</code>的版本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker version</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="v2-89ef2e517ffd86d80f65b6a0d2a0b159_720w.webp" alt="img"></p><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a><strong>查看镜像</strong></h3><p>上面我们拉取了hello-world的镜像，现在我们可以通过命令来查看镜像，命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="v2-240135177c5b1fbe9d8897dac4beec4c_720w.webp" alt="img"></p><p>出现上述情况，即表示我们成功在Ubuntu系统上安装了docker。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> centos </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置国内Docker镜像源</title>
      <link href="/posts/1ac1559c/"/>
      <url>/posts/1ac1559c/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>安装好 <code>Docker</code> 后，其 <code>registry server</code> 是默认指向 <code>https://hub.docker.com</code> 的。在国内该hub源访问速度异常慢，尤其是大一点的镜像经常出现timeout。</p><p>我们可以通过切换至国内镜像仓库来解决这一问题</p><h2 id="配置镜像仓库"><a href="#配置镜像仓库" class="headerlink" title="配置镜像仓库"></a>配置镜像仓库</h2><p>1.修改配置文件 <code>/etc/docker/daemon.json</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>2.增加或修改以下配置内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://dockerproxy.com&quot;,</span><br><span class="line">    &quot;https://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://mirror.baidubce.com&quot;,</span><br><span class="line">    &quot;https://ccr.ccs.tencentyun.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.重启docker，让配置生效</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>4.检查配置是否生效</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p>输出结果中显示 <code>Registry Mirrors</code> 为配置文件配置内容，说明配置成功</p><h2 id="Docker-hub-镜像源"><a href="#Docker-hub-镜像源" class="headerlink" title="Docker hub 镜像源"></a>Docker hub 镜像源</h2><p>推荐使用阿里云自己注册的</p><p><a href="https://jinianyoushang.github.io/posts/4c1a7ee4/">配置docker加速服务 | xd’s blog</a></p><div class="table-container"><table><thead><tr><th>提供商</th><th>公共镜像地址</th></tr></thead><tbody><tr><td>网易云</td><td><a href="https://link.zhihu.com/?target=http%3A//hub-mirror.c.163.com">http://hub-mirror.c.163.com</a></td></tr><tr><td>百度云</td><td><a href="https://link.zhihu.com/?target=http%3A//mirror.baidubce.com">http://mirror.baidubce.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://link.zhihu.com/?target=http%3A//ccr.ccs.tencentyun.com">http://ccr.ccs.tencentyun.com</a></td></tr><tr><td>Docker Proxy</td><td><a href="https://link.zhihu.com/?target=http%3A//dockerproxy.com">http://dockerproxy.com</a></td></tr><tr><td>Docker中国区官方</td><td><a href="https://registry.docker-cn.com">https://registry.docker-cn.com</a></td></tr><tr><td></td></tr></tbody></table></div><h2 id="测试镜像源是否有效"><a href="#测试镜像源是否有效" class="headerlink" title="测试镜像源是否有效"></a>测试镜像源是否有效</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull dockerproxy.com/library/nginx:latest</span><br><span class="line">docker pull hub-mirror.c.163.com/library/nginx:latest</span><br><span class="line">docker pull mirror.baidubce.com/library/nginx:latest</span><br><span class="line">docker pull ccr.ccs.tencentyun.com/library/nginx:latest</span><br></pre></td></tr></table></figure><h2 id="源镜像测速"><a href="#源镜像测速" class="headerlink" title="源镜像测速"></a>源镜像测速</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>在Linux下面有<code>time</code>命令，可以使用该命令对源进行测速：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time docker pull nginx:latest</span><br></pre></td></tr></table></figure><p>测速结果大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real   1m14.078s</span><br><span class="line">user   0m0.176s</span><br><span class="line">sys    0m0.120s</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在Windows的PowerShell下面可以使用以下命令测速：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Measure-Command</span> &#123;docker pull nginx:latest | <span class="built_in">Out-Default</span>&#125;</span><br></pre></td></tr></table></figure><p>测速结果大致如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Days              : <span class="number">0</span></span><br><span class="line">Hours             : <span class="number">0</span></span><br><span class="line">Minutes           : <span class="number">0</span></span><br><span class="line">Seconds           : <span class="number">4</span></span><br><span class="line">Milliseconds      : <span class="number">217</span></span><br><span class="line">Ticks             : <span class="number">42174202</span></span><br><span class="line">TotalDays         : <span class="number">4.88127337962963</span>E<span class="literal">-05</span></span><br><span class="line">TotalHours        : <span class="number">0.00117150561111111</span></span><br><span class="line">TotalMinutes      : <span class="number">0.0702903366666667</span></span><br><span class="line">TotalSeconds      : <span class="number">4.2174202</span></span><br><span class="line">TotalMilliseconds : <span class="number">4217.4202</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/7165806699461378085">Docker Hub 镜像源 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> 镜像源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最详细的ubuntu安装docker教程</title>
      <link href="/posts/3756cf19/"/>
      <url>/posts/3756cf19/</url>
      
        <content type="html"><![CDATA[<h2 id="系统版本"><a href="#系统版本" class="headerlink" title="系统版本"></a>系统版本</h2><p>本文以Ubuntu20.05系统为例安装docker，<a href="https://link.zhihu.com/?target=https%3A//ubuntu.com/download">Ubuntu官方下载地址</a>。</p><p>检查卸载老版本docker</p><p>ubuntu下自带了docker的库，不需要添加新的源。<br>但是ubuntu自带的docker版本太低，需要先卸载旧的再安装新的。</p><p>注：docker的旧版本不一定被称为docker，<a href="https://link.zhihu.com/?target=http%3A//docker.io">http://docker.io</a> 或 docker-engine也有可能，所以我们卸载的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><p>如果不能正常卸载，出现如下情况，显示无权限时，需要添加管理员权限才可进行卸载：</p><p><img src="v2-90241efe0f829a37c1db3fad3349c849_720w.webp" alt="img"></p><p>我们就需要使用<code>sudo apt-get remove docker docker-engine docker.io containerd runc</code>命令使用root权限来进行卸载。</p><p>安装步骤</p><h3 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h3><p>在终端中执行以下命令来更新Ubuntu软件包列表和已安装软件的版本:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装docker依赖"><a href="#安装docker依赖" class="headerlink" title="安装docker依赖"></a>安装docker依赖</h3><p>Docker在Ubuntu上依赖一些软件包。执行以下命令来安装这些依赖:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><h3 id="添加Docker官方GPG密钥"><a href="#添加Docker官方GPG密钥" class="headerlink" title="添加Docker官方GPG密钥"></a>添加Docker官方GPG密钥</h3><p>执行以下命令来添加Docker官方的GPG密钥:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="v2-0bd38706177023cfe438258e1009d83a_720w.webp" alt="img"></p><h3 id="添加Docker软件源"><a href="#添加Docker软件源" class="headerlink" title="添加Docker软件源"></a>添加Docker软件源</h3><p>执行以下命令来添加Docker的软件源:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure><p><strong>注：该命令需要使用root权限</strong></p><p><img src="v2-cbcdc65224f69f4e6c3c5ee5ac696012_720w.webp" alt="img"></p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>执行以下命令来安装Docker:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><h3 id="配置用户组（可选）"><a href="#配置用户组（可选）" class="headerlink" title="配置用户组（可选）"></a>配置用户组（可选）</h3><p>默认情况下，只有root用户和docker组的用户才能运行Docker命令。我们可以将当前用户添加到docker组，以避免每次使用Docker时都需要使用sudo。命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p><strong>注：重新登录才能使更改生效。</strong></p><p>运行docker</p><p>我们可以通过启动<code>docker</code>来验证我们是否成功安装。命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a><strong>安装工具</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><h3 id="重启docker"><a href="#重启docker" class="headerlink" title="重启docker"></a><strong>重启docker</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a><strong>验证是否成功</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>运行命令后，结果如下：</p><p><img src="v2-97314d2165190bb4a6926facc7e77eeb_720w.webp" alt="img"></p><p>因为我们之前没有拉取过<code>hello-world</code>，所以运行命令后会出现本地没有该镜像，并且会自动拉取的操作。</p><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a><strong>查看版本</strong></h3><p>我们可以通过下面的命令来查看<code>docker</code>的版本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker version</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="v2-89ef2e517ffd86d80f65b6a0d2a0b159_720w.webp" alt="img"></p><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a><strong>查看镜像</strong></h3><p>上面我们拉取了hello-world的镜像，现在我们可以通过命令来查看镜像，命令如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="v2-240135177c5b1fbe9d8897dac4beec4c_720w.webp" alt="img"></p><p>出现上述情况，即表示我们成功在Ubuntu系统上安装了docker。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> docker </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vcpkg常用命令说明</title>
      <link href="/posts/aa152842/"/>
      <url>/posts/aa152842/</url>
      
        <content type="html"><![CDATA[<h4 id="搜索可用库"><a href="#搜索可用库" class="headerlink" title="搜索可用库"></a>搜索可用库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg search ***</span><br></pre></td></tr></table></figure><h4 id="安装三方库"><a href="#安装三方库" class="headerlink" title="安装三方库"></a>安装三方库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install boost:x64-windows</span><br><span class="line"></span><br><span class="line">#移除一个开源库（已安装）注意：1. 默认移除 x86-winodws 版本库，如需移除其他版本库，需指定。</span><br><span class="line">#2. 只移除库本身，源码包和解压后的源码并未移除。</span><br><span class="line">vcpkg remove curl</span><br></pre></td></tr></table></figure><p>默认情况下，Vcpkg使用的编译环境是x86-windows, x64-linux.cmake或x64-osx.cmake。</p><h4 id="列出已安装的开源库"><a href="#列出已安装的开源库" class="headerlink" title="列出已安装的开源库"></a>列出已安装的开源库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg list</span><br></pre></td></tr></table></figure><h4 id="更新已安装的开源库"><a href="#更新已安装的开源库" class="headerlink" title="更新已安装的开源库"></a>更新已安装的开源库</h4><p>想要更新已安装的开源库，一般有两个指令：一个是update指令，可以显示可以升级的开源库的列表；另一个是upgrade的指令，会重新编译所有需要更新的包。</p><h4 id="导出已安装的开源库"><a href="#导出已安装的开源库" class="headerlink" title="导出已安装的开源库"></a>导出已安装的开源库</h4><p>想要导出已安装的开源库，那么执行 export 指令即可。比如我们要导出 curl 库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vcpkg export curl --7zip</span><br><span class="line"></span><br><span class="line">#注意：默认导出 x86-windows 版本库，如需导出其他版本，需指定。</span><br><span class="line">默认导出 vcpkg 目录下，默认导出包名称 vcpkg-export-日期-时间，如需指定目录和名称，使用 “-output=” 参数。</span><br><span class="line">　　　　　导出必须指定包格式：</span><br><span class="line">　　　　　　　--raw：以目录格式导出</span><br><span class="line">　　　　　　　--nuget：以 nuget 格式导出</span><br><span class="line">　　　　　　　--ifw：未知</span><br><span class="line">　　　　　　　--zip：以 zip 格式导出</span><br><span class="line">　　　　　　　--7zip：以 7z 格式导出</span><br></pre></td></tr></table></figure><h4 id="导入已备份的开源库"><a href="#导入已备份的开源库" class="headerlink" title="导入已备份的开源库"></a>导入已备份的开源库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg import xxx.7z</span><br></pre></td></tr></table></figure><h4 id="集成至Visual-Studio中-Windows"><a href="#集成至Visual-Studio中-Windows" class="headerlink" title="集成至Visual Studio中(Windows)"></a>集成至Visual Studio中(Windows)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vcpkg integrate install</span><br><span class="line"></span><br><span class="line">#取消集成</span><br><span class="line">vcpkg integrate remove</span><br></pre></td></tr></table></figure><h4 id="好用的库-安装多个库"><a href="#好用的库-安装多个库" class="headerlink" title="好用的库-安装多个库"></a>好用的库-安装多个库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install opencv4 eigen3 glm freeimage opencv opencv[contrib] opencv[ade] opencv[cuda] ceres opengl ceres boost glad glew --keep-going</span><br></pre></td></tr></table></figure><h4 id="解决网速慢"><a href="#解决网速慢" class="headerlink" title="解决网速慢"></a>解决网速慢</h4><p><strong>方法1：先下载，后编译</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vcpkg.exe install ceres --only-downloads</span><br><span class="line">vcpkg.exe install ceres</span><br></pre></td></tr></table></figure><p><strong>方法2：改端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果有proxy（没有就不用看了），下载还是很慢，就是端口号没设置好。</span><br><span class="line">在powershell中，注意是powershell而不是dos（不会真的有人用dos配置vcpkg吧），输入如下代码设置环境变量：</span><br><span class="line">下面只是临时改环境变量，</span><br><span class="line"></span><br><span class="line">$env:HTTP_PROXY=&quot;localhost:4780&quot;</span><br><span class="line">$env:HTTPS_PROXY=&quot;localhost:4780&quot;</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">集成到全局：vcpkg integrate install</span><br><span class="line">移除全局：vcpkg integrate remove</span><br><span class="line">集成到工程：vcpkg integrate project（在“\scripts\buildsystems”目录下，生成nuget配置文件）</span><br><span class="line">查看库目录：vcpkg search</span><br><span class="line">查看支持的架构：vcpkg help triplet</span><br><span class="line">指定编译某种架构的程序库：vcpkg install xxxx:x64-windows（x86-windows）</span><br><span class="line">卸载已安装库：vcpkg remove xxxx</span><br><span class="line">指定卸载平台：vcpkg remove xxxx:x64-windows</span><br><span class="line">移除所有旧版本库：vcpkg remove --outdated</span><br><span class="line">查看已经安装的库：vcpkg list</span><br><span class="line">更新已经安装的库：vcpkg update xxx</span><br><span class="line">导出已经安装的库：vcpkg export xxxx --7zip（–7zip –raw –nuget –ifw –zip）</span><br></pre></td></tr></table></figure><h4 id="vcpkg-目录文件及文件夹说明"><a href="#vcpkg-目录文件及文件夹说明" class="headerlink" title="vcpkg 目录文件及文件夹说明"></a>vcpkg 目录文件及文件夹说明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildtrees - 包含从中生成每个库的源的子文件夹，一般在xxxx.clean文件夹下。</span><br><span class="line">docs - 文档和示例。</span><br><span class="line">downloads - 所有已下载的工具或源的缓存副本。 运行安装命令时，vcpkg 会首先搜索此处。</span><br><span class="line">installed - 包含每个已安装库的标头和二进制文件。 与 Visual Studio 集成时，实质上是相当于告知它将此文件夹添加到其搜索路径。</span><br><span class="line">packages - 在不同的安装之间用于暂存的内部文件夹。</span><br><span class="line">ports - 用于描述每个库的目录、版本和下载位置的文件。 如有需要，可添加自己的端口。</span><br><span class="line">scripts - 由 vcpkg 使用的脚本（CMake、PowerShell）。</span><br><span class="line">toolsrc - vcpkg 和相关组件的 C++ 源代码。</span><br><span class="line">triplets - 包含每个受支持目标平台（如 x86-windows 或 x64-uwp）的设置。</span><br><span class="line"></span><br><span class="line">更新包指令 vcpkg upgrade --no-dry-run</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhuanlan.zhihu.com/p/383683670">vcpkg国内镜像使用方法 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/87391067">Vcpkg——C++包管理工具 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/hik-wxy/p/14744272.html">vcpkg：跨平台 C++ 包管理器的安装教程 - hik_wxy - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> vcpkg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> vcpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake (Clion) 中使用vcpkg</title>
      <link href="/posts/d5ac61a7/"/>
      <url>/posts/d5ac61a7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/microsoft/vcpkg#using-vcpkg-with-cmake">microsoft/vcpkg: C++ Library Manager for Windows, Linux, and MacOS (github.com)</a></p><p><strong>需要注意的是vcpkg在windows默认用MSVC进行编译，所以在项目中使用也应该用MSVC编译器才可以使用</strong></p><h3 id="使用-shell-安装软件包"><a href="#使用-shell-安装软件包" class="headerlink" title="使用 shell 安装软件包"></a>使用 shell 安装软件包</h3><p>以eigen3安装为例，在vcpkg的根目录下打开power shell，输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg install eigen3</span><br></pre></td></tr></table></figure><p>这里在安装成功之后一般会给出包的使用方法提示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find_package(Eigen3 CONFIG REQUIRED)</span><br><span class="line">target_link_libraries(main PRIVATE Eigen3::Eigen)</span><br></pre></td></tr></table></figure><h3 id="简单使用方式"><a href="#简单使用方式" class="headerlink" title="简单使用方式"></a>简单使用方式</h3><p>按照官方给出的办法使用包，方便之处在于不需要额外配置头文件和lib的路径，也不需要手动将dll文件放到bin目录下，vcpkg会自动完成这些配置。</p><p>如果你没有在环境变量中配置vcpkg的相关变量，而是在CMakeLists中配置vcpkg，需要注意把vcpkg的配置信息放在project之前，如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.21.0)</span><br><span class="line"></span><br><span class="line">set(VCPKG_ROOT &quot;E:/vcpkg&quot;)            # 手动设置到你的vcpkg根目录</span><br><span class="line">set(CMAKE_TOOLCHAIN_FILE &quot;$&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;)</span><br><span class="line"></span><br><span class="line">project(MyProject LANGUAGES CXX)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="openssl使用例子"><a href="#openssl使用例子" class="headerlink" title="openssl使用例子"></a>openssl使用例子</h3><p>安装openssl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install openssl</span><br></pre></td></tr></table></figure><p><img src="image-20240309163359578.png" alt="image-20240309163359578"></p><p>复制里面的内容,后面使用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PRIVATE OpenSSL::SSL OpenSSL::Crypto)</span><br></pre></td></tr></table></figure><p>打开Clion，新建项目，在CmakeLists.txt填入上面内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.26</span>)</span><br><span class="line"><span class="keyword">set</span>(VCPKG_ROOT <span class="string">&quot;C:/softwares/vcpkg-master&quot;</span>)            <span class="comment"># 手动设置到你的vcpkg根目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="string">&quot;$&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;</span>)</span><br><span class="line"><span class="keyword">project</span>(clion_demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里添加包</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE OpenSSL::SSL OpenSSL::Crypto)</span><br></pre></td></tr></table></figure><p>main.cpp文件如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 生成 RSA 密钥对</span></span><br><span class="line">    RSA *rsa = <span class="built_in">RSA_generate_key</span>(<span class="number">2048</span>, RSA_F4, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rsa) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to generate RSA key pair\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密明文</span></span><br><span class="line">    std::string plaintext = <span class="string">&quot;Hello, RSA!&quot;</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">ciphertext</span><span class="params">(RSA_size(rsa))</span></span>;</span><br><span class="line">    <span class="type">int</span> ciphertext_len = <span class="built_in">RSA_public_encrypt</span>(plaintext.<span class="built_in">size</span>(),</span><br><span class="line">                                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *&gt;(plaintext.<span class="built_in">c_str</span>()),</span><br><span class="line">                                            ciphertext.<span class="built_in">data</span>(), rsa, RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="keyword">if</span> (ciphertext_len == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;RSA encryption failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密密文</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">decryptedtext</span><span class="params">(RSA_size(rsa))</span></span>;</span><br><span class="line">    <span class="type">int</span> decryptedtext_len = <span class="built_in">RSA_private_decrypt</span>(ciphertext_len, ciphertext.<span class="built_in">data</span>(), decryptedtext.<span class="built_in">data</span>(), rsa,</span><br><span class="line">                                                RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="keyword">if</span> (decryptedtext_len == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;RSA decryption failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Plaintext: &quot;</span> &lt;&lt; plaintext &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Ciphertext: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ciphertext_len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>, ciphertext[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Decryptedtext: &quot;</span></span><br><span class="line">              &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(decryptedtext.<span class="built_in">data</span>()), decryptedtext_len) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 RSA 密钥对</span></span><br><span class="line">    <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 生成 RSA 密钥对</span></span><br><span class="line">    RSA* rsa = <span class="built_in">RSA_new</span>();</span><br><span class="line">    BIGNUM* exponent = <span class="built_in">BN_new</span>();</span><br><span class="line">    <span class="built_in">BN_set_word</span>(exponent, RSA_F4);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">RSA_generate_key_ex</span>(rsa, <span class="number">2048</span>, exponent, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to generate RSA key pair\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存公钥</span></span><br><span class="line">    std::string pubkey_filename = <span class="string">&quot;publickey.pem&quot;</span>;</span><br><span class="line">    FILE* pubkey_file = <span class="built_in">fopen</span>(pubkey_filename.<span class="built_in">c_str</span>(), <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pubkey_file) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create public key file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PEM_write_RSAPublicKey</span>(pubkey_file, rsa)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to write public key to file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(pubkey_file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存私钥</span></span><br><span class="line">    std::string privkey_filename = <span class="string">&quot;privatekey.pem&quot;</span>;</span><br><span class="line">    FILE* privkey_file = <span class="built_in">fopen</span>(privkey_filename.<span class="built_in">c_str</span>(), <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!privkey_file) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create private key file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PEM_write_RSAPrivateKey</span>(privkey_file, rsa, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to write private key to file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(privkey_file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">    <span class="built_in">BN_free</span>(exponent);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();     <span class="comment">//加密字符串例子</span></span><br><span class="line">    <span class="built_in">test02</span>();      <span class="comment">//c++ openssl生成公钥私钥保存到文件 有问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，表示可以成功使用</p><p><img src="image-20240309163710420.png" alt="image-20240309163710420"></p><h3 id="使用-vcpkg-json-为你的项目配置第三方依赖"><a href="#使用-vcpkg-json-为你的项目配置第三方依赖" class="headerlink" title="使用 vcpkg.json 为你的项目配置第三方依赖"></a>使用 vcpkg.json 为你的项目配置第三方依赖</h3><p>可能你的项目需要在多台电脑上编译，如果在每台电脑上都使用shell手动安装依赖库显然不是优雅的解决办法。又或者你的项目需要固定第三方依赖的版本，而vcpkg的命令行似乎没有给出选择软件包版本的选项，难道只能通过不更新vcpkg来使软件库永远保持在某个版本吗？那如果想对某个依赖的版本降级怎么办？</p><p>对于自动安装依赖的问题，vcpkg给出的解决办法是，在你的项目的根目录也就是顶级CMakeLists.txt所在目录创建名为vcpkg.json的配置文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;MyProject_dependencies&quot;,</span><br><span class="line">    &quot;version-semver&quot;:&quot;1.0.0&quot;,</span><br><span class="line">    &quot;dependencies&quot;:[</span><br><span class="line">        &quot;cgal&quot;,</span><br><span class="line">        &quot;eigen3&quot;,</span><br><span class="line">        &quot;freeimage&quot;,</span><br><span class="line">        &quot;glm&quot;,</span><br><span class="line">        &quot;glew&quot;,</span><br><span class="line">        &quot;flann&quot;,</span><br><span class="line">        &quot;lz4&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在环境变量或CMakeLists中配置变量</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(VCPKG_FEATURE_FLAGS &quot;version&quot;)          # 用于支持自定义依赖版本</span><br></pre></td></tr></table></figure><p>如此，不需要在shell手动安装软件包，运行cmake的时候vcpkg会自动将配置文件中的所有依赖安装到你项目的build\vcpkg_installed目录下。</p><h3 id="关于vcpkg支持哪些库"><a href="#关于vcpkg支持哪些库" class="headerlink" title="关于vcpkg支持哪些库"></a>关于vcpkg支持哪些库</h3><p>使用shell命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg search ***</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/615585442">VS2022 + vcpkg 使用 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/477497540">使用VCPKG管理你的第三方依赖 - 知乎 (zhihu.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/vcpkg/commands/install">vcpkg install | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/vcpkg/get_started/overview">vcpkg 概述 | Microsoft Learn</a></p>]]></content>
      
      
      <categories>
          
          <category> vcpkg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clion </tag>
            
            <tag> vcpkg </tag>
            
            <tag> Cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vcpkg管理C++项目依赖</title>
      <link href="/posts/67c5155/"/>
      <url>/posts/67c5155/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>vcpkg是微软公司开发的一个用于在多个平台上管理C++库的开源工具。它提供了一个简单易用的方式来下载、构建和安装各种C++库，以解决C++开发中的依赖管理问题</li><li>vcpkg支持Windows、macOS和Linux等多个操作系统，为开发人员提供了跨平台的便捷工具来集成和管理C++库。</li><li>提供了超过2000个C++库，可以一键安装常见的C++库：如Opencv、Qt、openssl、boost、glew、glad等；</li><li>缺点是，每个库都需要在本地自动编译，有的库安装时间较长。</li></ul><h2 id="vcpkg安装"><a href="#vcpkg安装" class="headerlink" title="vcpkg安装"></a>vcpkg安装</h2><h4 id="简单版本"><a href="#简单版本" class="headerlink" title="简单版本"></a>简单版本</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Microsoft/vcpkg.git</span><br><span class="line"><span class="built_in">cd</span> vcpkg</span><br><span class="line">./bootstrap-vcpkg.sh</span><br><span class="line">./vcpkg integrate install</span><br></pre></td></tr></table></figure><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>git地址：<a href="https://github.com/Microsoft/vcpkg">microsoft/vcpkg: C++ Library Manager for Windows, Linux, and MacOS (github.com)</a></p><p>可以使用命令clone下来：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Microsoft/vcpkg.git</span><br></pre></td></tr></table></figure><p>也可直接在网页上下载zip文件并解压</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>打开clone 下来的vcpkg目录（或解压的目录）</p><p>shift+鼠标右键打开powershell（或cmd）</p><p>输入如下命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bootstrap-vcpkg.bat</span><br></pre></td></tr></table></figure><p>完成后输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg.exe --help</span><br></pre></td></tr></table></figure><p>查看输出：</p><p><img src="v2-cdde573de4635e063b1b54d0fd36d909_720w.webp" alt="img"></p><p>将vcpkg目录加入环境变量中：</p><p>环境变量名：VCPKG_ROOT</p><p>值： vcpkg的安装目录，我的路径为C:\softwares\vcpkg-master</p><h2 id="集成到VS2022项目中"><a href="#集成到VS2022项目中" class="headerlink" title="集成到VS2022项目中"></a>集成到VS2022项目中</h2><p>1.在vcpkg文件夹中打开powershell或cmd，输入以下命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg integrate project</span><br></pre></td></tr></table></figure><p>查看输出：</p><p><img src="v2-c74d65934469621c3fd58fb33a104216_720w.webp" alt="img"></p><p>2.输入命令：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg integrate install</span><br></pre></td></tr></table></figure><p>查看输出：</p><p><img src="v2-6e081a5837120b462d7da066ab1dd1c4_720w.png" alt="img"></p><p>3.打开VS2022项目，打开NuGet包管理器：</p><p><img src="v2-f3bceec5e0115572e5d2797508ab3194_720w.png" alt="img"></p><p>将vcpkg添加在程序包源中，如图所示：</p><p><img src="v2-515c378010a7c08a66ba5a9ccd5eb718_720w.webp" alt="img"></p><p>4.右键工程， 管理NuGet程序包，程序包源选择vcpkg，点击浏览标签页，选择“vcpkg.E.git.vcpkg”并在右侧窗口点击安装</p><p><img src="v2-0a7c2c1f359008bc82330af77483bd7e_720w.webp" alt="img"></p><p>安装完成后即可使用vcpkg安装的三方库了。</p><h3 id="测试使用vcpkg安装boost-shared库版，并使用uuid模块进行测试"><a href="#测试使用vcpkg安装boost-shared库版，并使用uuid模块进行测试" class="headerlink" title="测试使用vcpkg安装boost shared库版，并使用uuid模块进行测试"></a>测试使用vcpkg安装boost shared库版，并使用uuid模块进行测试</h3><p>在vcpkg目录下打开powershell或cmd，输入如下命令安装boost1.81 shared版：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install boost:x64-windows</span><br></pre></td></tr></table></figure><p>vcpkg可支持如下类型：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Available architecture triplets:</span><br><span class="line">vcpkg built-in triplets:</span><br><span class="line">  arm-uwp</span><br><span class="line">  arm64-windows</span><br><span class="line">  x64-linux</span><br><span class="line">  x64-osx</span><br><span class="line">  x64-uwp</span><br><span class="line">  x64-windows-static</span><br><span class="line">  x64-windows</span><br><span class="line">  x86-windows</span><br><span class="line">VCPKG community triplets:</span><br><span class="line">  arm-android</span><br><span class="line">  arm-ios</span><br><span class="line">  arm-linux-release</span><br><span class="line">  arm-linux</span><br><span class="line">  arm-mingw-dynamic</span><br><span class="line">  arm-mingw-static</span><br><span class="line">  arm-neon-android</span><br><span class="line">  arm-uwp-static-md</span><br><span class="line">  arm-windows-static</span><br><span class="line">  arm-windows</span><br><span class="line">  arm64-android</span><br><span class="line">  arm64-ios</span><br><span class="line">  arm64-linux-release</span><br><span class="line">  arm64-linux</span><br><span class="line">  arm64-mingw-dynamic</span><br><span class="line">  arm64-osx-dynamic</span><br><span class="line">  arm64-osx-release</span><br><span class="line">  arm64-osx</span><br><span class="line">  arm64-uwp-static-md</span><br><span class="line">  arm64-uwp</span><br><span class="line">  arm64-windows-static-md</span><br><span class="line">  arm64-windows-static-release</span><br><span class="line">  arm64-windows-static</span><br><span class="line">  arm64ec-windows</span><br><span class="line">  armv6-android</span><br><span class="line">  ppc64le-linux-release</span><br><span class="line">  ppc64le-linux</span><br><span class="line">  riscv32-linux-release</span><br><span class="line">  riscv32-linux</span><br><span class="line">  riscv64-linux-release</span><br><span class="line">  riscv64-linux</span><br><span class="line">  s390x-linux-release</span><br><span class="line">  s390x-linux</span><br><span class="line">  wasm32-emscripten</span><br><span class="line">  x64-android</span><br><span class="line">  x64-freebsd</span><br><span class="line">  x64-ios</span><br><span class="line">  x64-linux-dynamic</span><br><span class="line">  x64-linux-release</span><br><span class="line">  x64-mingw-dynamic</span><br><span class="line">  x64-mingw-static</span><br><span class="line">  x64-openbsd</span><br><span class="line">  x64-osx-dynamic</span><br><span class="line">  x64-osx-release</span><br><span class="line">  x64-uwp-static-md</span><br><span class="line">  x64-windows-release</span><br><span class="line">  x64-windows-static-md</span><br><span class="line">  x64-windows-static-release</span><br><span class="line">  x64-xbox-scarlett-static</span><br><span class="line">  x64-xbox-scarlett</span><br><span class="line">  x64-xbox-xboxone-static</span><br><span class="line">  x64-xbox-xboxone</span><br><span class="line">  x86-android</span><br><span class="line">  x86-freebsd</span><br><span class="line">  x86-ios</span><br><span class="line">  x86-linux</span><br><span class="line">  x86-mingw-dynamic</span><br><span class="line">  x86-mingw-static</span><br><span class="line">  x86-uwp-static-md</span><br><span class="line">  x86-uwp</span><br><span class="line">  x86-windows-static-md</span><br><span class="line">  x86-windows-static</span><br><span class="line">  x86-windows-v120</span><br></pre></td></tr></table></figure><p>选择自己需要的类型进行安装，可安装多种</p><p>等待安装完成：</p><p><img src="v2-78d53d13d5a4066fbd1cc8a0365304c6_720w.webp" alt="img"></p><p>打开测试项目，并按照上一步对项目安装NuGet程序包源；</p><p>项目添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BOOST_UUID_FORCE_AUTO_LINK</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_generators.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/uuid/uuid_io.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::uuids;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">random_generator gen;</span><br><span class="line">uuid id = <span class="built_in">gen</span>();</span><br><span class="line">std::cout &lt;&lt; id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="v2-7e57caabdfacc8e425090a832cf273fb_720w.webp" alt="img"></p><p>编译并运行：</p><p><img src="v2-c8846ffb67a176311057bea3b795088b_720w.webp" alt="img"></p><p>说明boost库在vcpkg中安装成功，并成功在VS2022工程中使用。</p><h2 id="CMake（Clion）-vcpkg"><a href="#CMake（Clion）-vcpkg" class="headerlink" title="CMake（Clion）+vcpkg"></a>CMake（Clion）+vcpkg</h2><p><a href="https://github.com/microsoft/vcpkg#using-vcpkg-with-cmake">microsoft/vcpkg: C++ Library Manager for Windows, Linux, and MacOS (github.com)</a></p><p><strong>需要注意的是vcpkg在windows默认用MSVC进行编译，所以在项目中使用也应该用MSVC编译器才可以使用</strong></p><h3 id="使用-shell-安装软件包"><a href="#使用-shell-安装软件包" class="headerlink" title="使用 shell 安装软件包"></a>使用 shell 安装软件包</h3><p>以eigen3安装为例，在vcpkg的根目录下打开power shell，输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg install eigen3</span><br></pre></td></tr></table></figure><p>这里在安装成功之后一般会给出包的使用方法提示</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find_package(Eigen3 CONFIG REQUIRED)</span><br><span class="line">target_link_libraries(main PRIVATE Eigen3::Eigen)</span><br></pre></td></tr></table></figure><h3 id="简单使用方式"><a href="#简单使用方式" class="headerlink" title="简单使用方式"></a>简单使用方式</h3><p>按照官方给出的办法使用包，方便之处在于不需要额外配置头文件和lib的路径，也不需要手动将dll文件放到bin目录下，vcpkg会自动完成这些配置。</p><p>如果你没有在环境变量中配置vcpkg的相关变量，而是在CMakeLists中配置vcpkg，需要注意把vcpkg的配置信息放在project之前，如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.21.0)</span><br><span class="line"></span><br><span class="line">set(VCPKG_ROOT &quot;E:/vcpkg&quot;)            # 手动设置到你的vcpkg根目录</span><br><span class="line">set(CMAKE_TOOLCHAIN_FILE &quot;$&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;)</span><br><span class="line"></span><br><span class="line">project(MyProject LANGUAGES CXX)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="openssl使用例子"><a href="#openssl使用例子" class="headerlink" title="openssl使用例子"></a>openssl使用例子</h3><p>安装openssl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcpkg install openssl</span><br></pre></td></tr></table></figure><p><img src="image-20240309163359578.png" alt="image-20240309163359578"></p><p>复制里面的内容,后面使用</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PRIVATE OpenSSL::SSL OpenSSL::Crypto)</span><br></pre></td></tr></table></figure><p>打开Clion，新建项目，在CmakeLists.txt填入上面内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.26</span>)</span><br><span class="line"><span class="keyword">set</span>(VCPKG_ROOT <span class="string">&quot;C:/softwares/vcpkg-master&quot;</span>)            <span class="comment"># 手动设置到你的vcpkg根目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_TOOLCHAIN_FILE <span class="string">&quot;$&#123;VCPKG_ROOT&#125;/scripts/buildsystems/vcpkg.cmake&quot;</span>)</span><br><span class="line"><span class="keyword">project</span>(clion_demo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里添加包</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE OpenSSL::SSL OpenSSL::Crypto)</span><br></pre></td></tr></table></figure><p>main.cpp文件如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/pem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 生成 RSA 密钥对</span></span><br><span class="line">    RSA *rsa = <span class="built_in">RSA_generate_key</span>(<span class="number">2048</span>, RSA_F4, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rsa) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to generate RSA key pair\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加密明文</span></span><br><span class="line">    std::string plaintext = <span class="string">&quot;Hello, RSA!&quot;</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">ciphertext</span><span class="params">(RSA_size(rsa))</span></span>;</span><br><span class="line">    <span class="type">int</span> ciphertext_len = <span class="built_in">RSA_public_encrypt</span>(plaintext.<span class="built_in">size</span>(),</span><br><span class="line">                                            <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *&gt;(plaintext.<span class="built_in">c_str</span>()),</span><br><span class="line">                                            ciphertext.<span class="built_in">data</span>(), rsa, RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="keyword">if</span> (ciphertext_len == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;RSA encryption failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解密密文</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">decryptedtext</span><span class="params">(RSA_size(rsa))</span></span>;</span><br><span class="line">    <span class="type">int</span> decryptedtext_len = <span class="built_in">RSA_private_decrypt</span>(ciphertext_len, ciphertext.<span class="built_in">data</span>(), decryptedtext.<span class="built_in">data</span>(), rsa,</span><br><span class="line">                                                RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="keyword">if</span> (decryptedtext_len == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;RSA decryption failed\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Plaintext: &quot;</span> &lt;&lt; plaintext &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Ciphertext: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ciphertext_len; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>, ciphertext[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Decryptedtext: &quot;</span></span><br><span class="line">              &lt;&lt; std::<span class="built_in">string</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(decryptedtext.<span class="built_in">data</span>()), decryptedtext_len) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 RSA 密钥对</span></span><br><span class="line">    <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 生成 RSA 密钥对</span></span><br><span class="line">    RSA* rsa = <span class="built_in">RSA_new</span>();</span><br><span class="line">    BIGNUM* exponent = <span class="built_in">BN_new</span>();</span><br><span class="line">    <span class="built_in">BN_set_word</span>(exponent, RSA_F4);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">RSA_generate_key_ex</span>(rsa, <span class="number">2048</span>, exponent, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to generate RSA key pair\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存公钥</span></span><br><span class="line">    std::string pubkey_filename = <span class="string">&quot;publickey.pem&quot;</span>;</span><br><span class="line">    FILE* pubkey_file = <span class="built_in">fopen</span>(pubkey_filename.<span class="built_in">c_str</span>(), <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pubkey_file) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create public key file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PEM_write_RSAPublicKey</span>(pubkey_file, rsa)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to write public key to file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(pubkey_file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存私钥</span></span><br><span class="line">    std::string privkey_filename = <span class="string">&quot;privatekey.pem&quot;</span>;</span><br><span class="line">    FILE* privkey_file = <span class="built_in">fopen</span>(privkey_filename.<span class="built_in">c_str</span>(), <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!privkey_file) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to create private key file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">PEM_write_RSAPrivateKey</span>(privkey_file, rsa, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to write private key to file\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(privkey_file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="built_in">RSA_free</span>(rsa);</span><br><span class="line">    <span class="built_in">BN_free</span>(exponent);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();     <span class="comment">//加密字符串例子</span></span><br><span class="line">    <span class="built_in">test02</span>();      <span class="comment">//c++ openssl生成公钥私钥保存到文件 有问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，表示可以成功使用</p><p><img src="image-20240309163710420.png" alt="image-20240309163710420"></p><h3 id="使用-vcpkg-json-为你的项目配置第三方依赖"><a href="#使用-vcpkg-json-为你的项目配置第三方依赖" class="headerlink" title="使用 vcpkg.json 为你的项目配置第三方依赖"></a>使用 vcpkg.json 为你的项目配置第三方依赖</h3><p>可能你的项目需要在多台电脑上编译，如果在每台电脑上都使用shell手动安装依赖库显然不是优雅的解决办法。又或者你的项目需要固定第三方依赖的版本，而vcpkg的命令行似乎没有给出选择软件包版本的选项，难道只能通过不更新vcpkg来使软件库永远保持在某个版本吗？那如果想对某个依赖的版本降级怎么办？</p><p>对于自动安装依赖的问题，vcpkg给出的解决办法是，在你的项目的根目录也就是顶级CMakeLists.txt所在目录创建名为vcpkg.json的配置文件：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;MyProject_dependencies&quot;,</span><br><span class="line">    &quot;version-semver&quot;:&quot;1.0.0&quot;,</span><br><span class="line">    &quot;dependencies&quot;:[</span><br><span class="line">        &quot;cgal&quot;,</span><br><span class="line">        &quot;eigen3&quot;,</span><br><span class="line">        &quot;freeimage&quot;,</span><br><span class="line">        &quot;glm&quot;,</span><br><span class="line">        &quot;glew&quot;,</span><br><span class="line">        &quot;flann&quot;,</span><br><span class="line">        &quot;lz4&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在环境变量或CMakeLists中配置变量</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(VCPKG_FEATURE_FLAGS &quot;version&quot;)          # 用于支持自定义依赖版本</span><br></pre></td></tr></table></figure><p>如此，不需要在shell手动安装软件包，运行cmake的时候vcpkg会自动将配置文件中的所有依赖安装到你项目的build\vcpkg_installed目录下。</p><h3 id="关于vcpkg支持哪些库"><a href="#关于vcpkg支持哪些库" class="headerlink" title="关于vcpkg支持哪些库"></a>关于vcpkg支持哪些库</h3><p>使用shell命令</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./vcpkg search ***</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/615585442">VS2022 + vcpkg 使用 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/477497540">使用VCPKG管理你的第三方依赖 - 知乎 (zhihu.com)</a></p><p><a href="https://learn.microsoft.com/zh-cn/vcpkg/commands/install">vcpkg install | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/vcpkg/get_started/overview">vcpkg 概述 | Microsoft Learn</a></p><p><a href="https://github.com/microsoft/vcpkg#using-vcpkg-with-cmake">microsoft/vcpkg: C++ Library Manager for Windows, Linux, and MacOS (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> vcpkg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clion </tag>
            
            <tag> C++ </tag>
            
            <tag> vcpkg </tag>
            
            <tag> Cmake </tag>
            
            <tag> VS2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Clion中开发Qt</title>
      <link href="/posts/56c9a421/"/>
      <url>/posts/56c9a421/</url>
      
        <content type="html"><![CDATA[<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>使用clion 创建一个QT工程，注意其中Qt CMake前缀路径的选择：</p><p>语言标准，Qt5最高选择C++14，Qt6可以选择C++17</p><p><img src="image-20240309150148931.png" alt="image-20240309150148931"></p><p>新建好的工程如下：</p><p><img src="image-20240309150450123.png" alt="image-20240309150450123"></p><p>这个时候直接编译运行可能会出错，</p><p><img src="image-20240309151831642.png" alt="image-20240309151831642"></p><p>我们需要将<code>CMakeLists.txt</code>中的</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MSVC <span class="keyword">AND</span> CMAKE_BUILD_TYPE <span class="keyword">MATCHES</span> <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(DEBUG_SUFFIX <span class="string">&quot;d&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (CMAKE_BUILD_TYPE MATCHES &quot;Debug&quot;)</span><br><span class="line">    set(DEBUG_SUFFIX &quot;d&quot;)</span><br><span class="line">endif ()</span><br></pre></td></tr></table></figure><h2 id="修改cmake"><a href="#修改cmake" class="headerlink" title="修改cmake"></a>修改cmake</h2><p>此时<code>CMakeLists.txt</code>文件内容为</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.28</span>)</span><br><span class="line"><span class="keyword">project</span>(testQt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOMOC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTORCC <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_AUTOUIC <span class="keyword">ON</span>)  <span class="comment">#自动将ui翻译为h文件，无须手动转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH <span class="string">&quot;C:/xd/Qt/5.13.1/mingw73_64/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 COMPONENTS</span><br><span class="line">        Core</span><br><span class="line">        Gui</span><br><span class="line">        Widgets</span><br><span class="line">        REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(testQt src/main.cpp</span><br><span class="line">        src/mainwindows.cpp</span><br><span class="line">        src/mainwindows.h</span><br><span class="line">        src/mainwindows.ui</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(testQt</span><br><span class="line">        Qt5::Core</span><br><span class="line">        Qt5::Gui</span><br><span class="line">        Qt5::Widgets</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#这段代码的意思大概是：将dll文件复制到可执行文件所在目录</span></span><br><span class="line"><span class="keyword">if</span> (WIN32 <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">DEFINED</span> CMAKE_TOOLCHAIN_FILE)</span><br><span class="line">    <span class="keyword">set</span>(DEBUG_SUFFIX)</span><br><span class="line"><span class="comment">#    if (MSVC AND CMAKE_BUILD_TYPE MATCHES &quot;Debug&quot;)</span></span><br><span class="line"><span class="comment">#        set(DEBUG_SUFFIX &quot;d&quot;)</span></span><br><span class="line"><span class="comment">#    endif ()</span></span><br><span class="line">    <span class="keyword">if</span> (CMAKE_BUILD_TYPE <span class="keyword">MATCHES</span> <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(DEBUG_SUFFIX <span class="string">&quot;d&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span> ()</span><br><span class="line">    <span class="keyword">set</span>(QT_INSTALL_PATH <span class="string">&quot;$&#123;CMAKE_PREFIX_PATH&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">&quot;$&#123;QT_INSTALL_PATH&#125;/bin&quot;</span>)</span><br><span class="line">        <span class="keyword">set</span>(QT_INSTALL_PATH <span class="string">&quot;$&#123;QT_INSTALL_PATH&#125;/..&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">&quot;$&#123;QT_INSTALL_PATH&#125;/bin&quot;</span>)</span><br><span class="line">            <span class="keyword">set</span>(QT_INSTALL_PATH <span class="string">&quot;$&#123;QT_INSTALL_PATH&#125;/..&quot;</span>)</span><br><span class="line">        <span class="keyword">endif</span> ()</span><br><span class="line">    <span class="keyword">endif</span> ()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">EXISTS</span> <span class="string">&quot;$&#123;QT_INSTALL_PATH&#125;/plugins/platforms/qwindows$&#123;DEBUG_SUFFIX&#125;.dll&quot;</span>)</span><br><span class="line">        <span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> POST_BUILD</span><br><span class="line">                <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E <span class="keyword">make_directory</span></span><br><span class="line">                <span class="string">&quot;$&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;/plugins/platforms/&quot;</span>)</span><br><span class="line">        <span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> POST_BUILD</span><br><span class="line">                <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy</span><br><span class="line">                <span class="string">&quot;$&#123;QT_INSTALL_PATH&#125;/plugins/platforms/qwindows$&#123;DEBUG_SUFFIX&#125;.dll&quot;</span></span><br><span class="line">                <span class="string">&quot;$&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;/plugins/platforms/&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span> ()</span><br><span class="line">    <span class="keyword">foreach</span> (QT_LIB Core Gui Widgets)</span><br><span class="line">        <span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> POST_BUILD</span><br><span class="line">                <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy</span><br><span class="line">                <span class="string">&quot;$&#123;QT_INSTALL_PATH&#125;/bin/Qt5$&#123;QT_LIB&#125;$&#123;DEBUG_SUFFIX&#125;.dll&quot;</span></span><br><span class="line">                <span class="string">&quot;$&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">endforeach</span> (QT_LIB)</span><br><span class="line"><span class="keyword">endif</span> ()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上模板仅供参考。</p><p><img src="image-20240309152234170.png" alt="image-20240309152234170"></p><p>这个时候Debug模式和release模式均可以运行</p><p><img src="image-20240309152300989.png" alt="image-20240309152300989"></p><p>需要注意的是</p><p>如果安装的qt是mingw版本的工具链使用的也应该是Mingw版本，MSVC也同理。否则不能运行</p><p><img src="image-20240309152437581.png" alt="image-20240309152437581"></p><h2 id="重构目录"><a href="#重构目录" class="headerlink" title="重构目录"></a>重构目录</h2><p>在这里，为了目录结构的清晰，我们简单重构一下我们的项目目录。重构后如下：</p><ul><li>新建一个src文件夹用来保存源代码包括  <em>.h  </em>.cpp  *.ui，也可以使用子文件夹，对大的Qt项目分模块</li><li>test，用来保存测试代码。</li><li>third_party，用来保存我们使用的第三方源代码，动态库，静态库等。</li><li>resource，用来保存qrc资源文件，图片文件等。</li><li>include(可选)，用来把我们项目的头文件暴漏给其他人使用。</li></ul><p><img src="image-20240309153316013.png" alt="image-20240309153316013"></p><h2 id="新建界面UI类"><a href="#新建界面UI类" class="headerlink" title="新建界面UI类"></a>新建界面UI类</h2><p>对着左侧项目根目录右键，选择新建，新建一个QT Ui类：</p><p><img src="image-20240309153355541.png" alt="image-20240309153355541"></p><p>给新建的UI类起一个名字，这里就叫做<code>QMainWindow</code>，基类我们选择<code>QMainwindow</code>,此时我们可以看到，clion 会自动帮我们把新生成的文件添加到cmake中：</p><p><img src="image-20240309153630744.png" alt="image-20240309153630744"></p><h2 id="修改main-cpp"><a href="#修改main-cpp" class="headerlink" title="修改main.cpp"></a>修改main.cpp</h2><p>然后我们将<code>main.cpp</code>修改为以下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mainwindows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Mainwindows w;</span><br><span class="line">    w.<span class="built_in">show</span> ();</span><br><span class="line">    <span class="keyword">return</span> QApplication::<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行，就能看到我们的结果啦：</p><p><img src="image-20240309153901473.png" alt="image-20240309153901473"></p><h2 id="在clion-中添加外部工具"><a href="#在clion-中添加外部工具" class="headerlink" title="在clion 中添加外部工具"></a>在clion 中添加外部工具</h2><p>在设置中的外部工具中，添加一个新的外部工具，指向<code>designer.exe</code>：</p><p><img src="image-20240309154033982.png" alt="image-20240309154033982"></p><p>然后我们就能对着UI文件右键，选择外部工具，最后使用QtDesigner打开它：</p><p><img src="image-20240309154108019.png" alt="image-20240309154108019"></p><h2 id="设置ui文件双击打开"><a href="#设置ui文件双击打开" class="headerlink" title="设置ui文件双击打开"></a>设置ui文件双击打开</h2><p>如果您将Qt Designer与Qt分开安装，CLion可能无法检测到它，并将在编辑器中打开<strong>.ui</strong>文件。在这种情况下，请执行以下操作以在Qt Designer中打开它们：</p><p>前往设置-&gt;编辑器-&gt;文件类型</p><p>从“识别的文件类型”列表中选择“Qt UI Designer Form”，然后删除关联的文件扩展名：</p><p><img src="/cl_qt_ui_removeassoc.png" alt="删除 .ui 文件的关联" style="zoom: 50%;" /></p><p>选择在关联的应用程序中打开的文件并添加扩展名：<code>.ui</code></p><p><img src="image-20240309154441929.png" alt="image-20240309154441929"></p><p>保存。</p><p>同时确保ui文件在系统的默认打开方式是Qt Designer ，如果不是，则应该右击ui文件并设置打开方式为</p><p>默认应用。</p><p><img src="image-20240309154645778.png" alt="image-20240309154645778"></p><p>此时双击ui文件既可以开打Qt Designer</p><p><img src="image-20240309154931074.png" alt="image-20240309154931074"></p><h2 id="添加qrc资源文件"><a href="#添加qrc资源文件" class="headerlink" title="添加qrc资源文件"></a>添加qrc资源文件</h2><p>可以在Qt Designer中手动添加，点击资源浏览器资源编辑，新建资源。</p><p><img src="image-20240309155214235.png" alt="image-20240309155214235"></p><p>文件名为src.qrc 保存到项目新建的resource目录。</p><p>添加图片文件</p><p><img src="image-20240309155420695.png" alt="image-20240309155420695"></p><p><img src="image-20240309155757368.png" alt="image-20240309155757368"></p><p>给主窗口添加背景图，并保存</p><p><img src="image-20240309155928178.png" alt="image-20240309155928178"></p><p>给CMakeLists.txt添加资源文件 <code>resource/src.qrc</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(testQt src/main.cpp</span><br><span class="line">        src/mainwindows.cpp</span><br><span class="line">        src/mainwindows.h</span><br><span class="line">        src/mainwindows.ui</span><br><span class="line">        resource/src.qrc</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>运行即可看到效果</p><p><img src="image-20240309160417823.png" alt="image-20240309160417823" style="zoom: 67%;" /></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/461896034">使用 clion 开发 QT - 知乎 (zhihu.com)</a></p><p><a href="https://www.jetbrains.com/help/clion/qt-tutorial.html#fcb888de_226">Qt项目 |CLion 文档 (jetbrains.com)</a></p><p><a href="https://www.jetbrains.com/help/clion/qml-syntax-support.html#extra-imports">QML语法支持 |CLion 文档 (jetbrains.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clion </tag>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly优化搜索引擎收录</title>
      <link href="/posts/e302e79f/"/>
      <url>/posts/e302e79f/</url>
      
        <content type="html"><![CDATA[<p>我们必须把我们的网站推送到搜索引擎那， 否则别人除了输入我们的域名或者搜索文章，是没法发现我们的博文。</p><h2 id="1-查看是否被收录"><a href="#1-查看是否被收录" class="headerlink" title="1. 查看是否被收录"></a>1. 查看是否被收录</h2><p>使用想要查找的搜索引擎，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">site:你的网站</span><br><span class="line">比如我的：site:qmike.top</span><br></pre></td></tr></table></figure><h2 id="2-永久化-URL-网址链接"><a href="#2-永久化-URL-网址链接" class="headerlink" title="2. 永久化 URL 网址链接"></a>2. 永久化 URL 网址链接</h2><blockquote><p>我们可以发现 hexo 默认生成的文章地址路径是 【网站名称／年／月／日／文章名称】。</p><p>这种链接对搜索爬虫是很不友好的，第一它的 url 结构超过了三层，太深了。</p></blockquote><p>安装 <code>abbrlink</code> 插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><p>关于此插件的详细信息参见它的<a href="https://github.com/rozbo/hexo-abbrlink">官方文档</a>。作用是将文章的链接转换成数字后字母，即将博客网站的网页转成<code>.html</code> 永久链接的格式，有利于搜索引擎的收录。</p><p>修改 hexo 根目录下 <code>config.yml</code> 中的 <code>permalink</code> 的值：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://qmike.top</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br></pre></td></tr></table></figure><p>在 <code>config.yml</code> 最底下添加 <code>abbrlink config</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># abbrlink config</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>      <span class="comment"># support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>        <span class="comment"># support dec(default) and hex</span></span><br><span class="line"><span class="comment"># 不用添加其它代码</span></span><br></pre></td></tr></table></figure><p>配置完成后，网站的链接应该类似这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://qmike.top/posts/77940e6f.html        # 有.html后缀 </span><br></pre></td></tr></table></figure><h2 id="3-站点地图"><a href="#3-站点地图" class="headerlink" title="3. 站点地图"></a>3. 站点地图</h2><p>站点地图即 <a href="https://baike.baidu.com/item/sitemap/6241567?fr=aladdin">sitemap</a>， 是一个页面，上面放置了网站上需要搜索引擎抓取的所有页面的链接。站点地图可以告诉搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。所以我们首先需要生成一个站点地图。</p><p>安装百度和 Google 的站点地图生成插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>然后来到 hexo 根目录配置文件 <code>config.yml</code>，在下面添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 站点地图</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure><p>然后重新推送到服务器，访问如下 URL:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://你的域名/sitemap.xml</span><br><span class="line">https://你的域名/baidusitemap.xml</span><br></pre></td></tr></table></figure><p>看看网页中有没有出现代码。有的话就成功。</p><blockquote><p>注意代码中的域名是否和自己网站的一样，使用 <code>github page</code> 部署的网站，可能会出现域名不同的情况，需要之前完成 token 令牌密钥的验证，<a href="https://www.bilibili.com/video/BV1W34y1o7yK/?spm_id_from=333.788&amp;vd_source=8bba695aa4490252230ffd2e2cc0609b">视频</a>中有介绍。</p></blockquote><p>给你的 hexo 网站添加蜘蛛协议 robots.txt, 把 robots.txt 放在你的 hexo 站点的 source 文件下即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line"></span><br><span class="line">Sitemap: https://&#123;域名&#125;/sitemap.xml</span><br><span class="line">Sitemap: https://&#123;域名&#125;/baidusitemap.xml</span><br></pre></td></tr></table></figure><h2 id="4-百度收录"><a href="#4-百度收录" class="headerlink" title="4. 百度收录"></a>4. 百度收录</h2><h3 id="提交网站"><a href="#提交网站" class="headerlink" title="提交网站"></a>提交网站</h3><p>通过百度站长平台进行链接提交，增加网站的索引量。先去注册并登录：<a href="https://ziyuan.baidu.com/?castk=LTE=">百度站长平台</a></p><p><a href="https://mikepicture.oss-cn-chengdu.aliyuncs.com/picture/image-20220904180119988.png"><img src="image-20220904180119988-17098752495171.png" alt="image-20220904180119988"></a></p><p>需要验证网站，我选择的是 <a href="https://，这根据你前面是否添加">https://，这根据你前面是否添加</a> SSL 证书来选择。并且我使用的是不带 www 的，看个人。然后到第三步，我使用的 HTML 标签验证。</p><p><a href="https://mikepicture.oss-cn-chengdu.aliyuncs.com/picture/image-20220904181206160.png"><img src="image-20220904181206160-17098752495172.png" alt="img"></a></p><p>把 <code>content</code> 中的字符串复制到主题配置文件<code>_config.butterfly.yml</code> 中的 <code>baidu_site_verification</code> 。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Baidu Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://ziyuan.baidu.com/site</span></span><br><span class="line"><span class="attr">site_verification:</span></span><br><span class="line">  <span class="comment"># - name: google-site-verification</span></span><br><span class="line">  <span class="comment">#   content: xxxxxx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">baidu-site-verification</span></span><br><span class="line">    <span class="attr">content:</span>  <span class="comment"># 在这里填上面的字符串</span></span><br></pre></td></tr></table></figure><blockquote><p>需要将网站部署完后，再去百度站长平台完成 HTML 标签验证</p></blockquote><h3 id="提交链接"><a href="#提交链接" class="headerlink" title="提交链接"></a>提交链接</h3><p>百度站长平台的链接提交方式分为自动提交和手动提交两种，此处只讲自动提交，手动提交按照要求操作即可。</p><p><strong>主动推送</strong>最为快速的提交方式，是被百度收录最快的推送方式。主动推送可以通过安装插件实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure><p>然后在 hexo 根目录配置文件<code>_config.yml</code> 中，添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主动推送百度，被百度收录</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">10</span> <span class="comment"># 提交最新的10个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="comment"># 百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="comment"># 秘钥，百度站长平台 &gt; 普通收录 &gt; 推送接口 &gt; 接口调用地址中token字段</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址， 新链接会保存在此文本文档里，不用改</span></span><br></pre></td></tr></table></figure><ul><li><p>host 为自己网站的域名，例如我的为 <code>https://qmike.top</code></p></li><li><p>token 需要打开 “普通收录–&gt; 推送接口” 进行查看</p><p><img src="image-20220904212055771-17098752495173.png" alt="image-20220904212055771"></p></li></ul><p>其次，记得查看 hexo 根目录中<code>_config.yml</code> 文件中<code>url</code> 的值， 必须包含是百度站长平台注册的域名。</p><p>最后，在<code>_config.yml</code> 文件中的 <code>deploy</code> 加入新的 <code>type</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">https://github.com/fenshen000/fenshen000.github.io.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br></pre></td></tr></table></figure><blockquote><p>这里是新建一个 type，一定要注意这段代码里面各行的缩进值</p></blockquote><p>其主动推送的实现原理如下：</p><ul><li><p>新链接的产生， <code>hexo generate</code> 会产生一个文本文件，里面包含最新的链接</p></li><li><p>新链接的提交， <code>hexo deploy</code> 会从上述文件中读取链接，提交至百度搜索引擎</p><blockquote><p>不知道对于部署在 Netlify 上的网站有没有用，再查查资料</p></blockquote></li></ul><p>若要实现手动提交，则把下面的代码粘贴到百度站长平台的 “手动收录” 地址窗口即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://你的域名/sitemap.xml</span><br><span class="line">https://你的域名/baidusitemap.xml</span><br></pre></td></tr></table></figure><p><a href="https://mikepicture.oss-cn-chengdu.aliyuncs.com/picture/image-20220904213924274.png"><img src="image-20220904213924274-17098752495174.png" alt="image-20220904213924274"></a></p><p>后续慢慢等收录吧，百度收录比较慢。</p><h2 id="5-谷歌收录"><a href="#5-谷歌收录" class="headerlink" title="5. 谷歌收录"></a>5. 谷歌收录</h2><p>提交谷歌搜索引擎比较简单，在提交之前，我们依然可以使用 <code>site:域名</code> 查看网站是否被收录。进入 <a href="https://developers.google.com/search#?modal_active=none">Google 搜索中心</a>，登录你的谷歌账号。然后找到<a href="https://search.google.com/search-console/welcome">注册 Search Console</a>(在 “使用入门–&gt;SEO 新手指南” 中可以找到入口)，就直接输入你要收录的网站域名就行。</p><p>详细操作参考谷歌的<a href="https://support.google.com/webmasters/answer/9008080#html_verification&amp;zippy=%2C域名提供商%2Chtml-标记%2Chtml-文件上传">官方指南</a></p><p><a href="https://mikepicture.oss-cn-chengdu.aliyuncs.com/picture/image-20220904220444787.png"><img src="image-20220904220444787-17098752495175.png" alt="image-20220904220444787"></a></p><p>选择第一个或者第二个都可以的，我这里两个都选择了。</p><p>“网址前缀” 验证很简单，输入网址 <code>https://qmike.top</code> 即可直接验证。“网域” 验证较为复杂，点击 “继续” 后，操作如下：</p><blockquote><p>可以添加所有的网址变体，包括 https，http，www 和非 www 变体</p></blockquote><p><a href="https://mikepicture.oss-cn-chengdu.aliyuncs.com/picture/image-20220904221520736.png"><img src="image-20220904221520736-17098752495176.png" alt="image-20220904221520736"></a></p><p>打开你的域名提供商网站，在里面添加 “解析设置”。以阿里云为例：</p><ul><li><p>打开域名的 “解析设置”，点击 “添加记录”</p><p><img src="image-20220904224419062-17098752495177.png" alt="image-20220904224419062"></p></li><li><p>“记录类型” 选择 “TXT”，“主机记录” 选择 “@”，记录值写入上面复制的 TXT 记录值</p><p><img src="image-20220904225057831-17098752495178.png" alt="image-20220904225057831"></p></li><li><p>重新部署后返回谷歌页面进行验证，可能需要等待一段时间。</p></li></ul><p><a href="https://mikepicture.oss-cn-chengdu.aliyuncs.com/picture/20200403223509.png"><img src="20200403223509-17098752495179.png" alt="20200403223509"></a></p><p>两种方式，你可以下载个 HTML 文件然后放在站点目录下的 <code>source</code> 中，然后推送到服务器。或者把 <code>content</code> 中的字符串复制到主题配置文件<code>_config.butterfly.yml</code> 对应内容中：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">site_verification:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">google-site-verification</span></span><br><span class="line">    <span class="attr">content:</span> <span class="comment"># 在这里填上面的字符串</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">baidu-site-verification</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">XXXXX</span></span><br></pre></td></tr></table></figure><blockquote><p>部署网站到 Netlify，一天时间便会自动收录</p></blockquote><h2 id="6-必应收录"><a href="#6-必应收录" class="headerlink" title="6. 必应收录"></a>6. 必应收录</h2><p>必应收录也是很简单，点击<a href="https://www.bing.com/webmasters/about">必应站长</a>。先注册登录，必应收录有两种方式，一种使用刚刚谷歌导入过去，第二种是就是自己添加 URL</p><h2 id="7-其它收录"><a href="#7-其它收录" class="headerlink" title="7. 其它收录"></a>7. 其它收录</h2><p>其他搜索引擎的收录都很类似，就不一一赘述了。</p><h2 id="8-添加-nofollow-标签"><a href="#8-添加-nofollow-标签" class="headerlink" title="8. 添加 nofollow 标签"></a>8. 添加 nofollow 标签</h2><p>给非友情链接的出站链接添加「nofollow」标签，nofollow 标签是由谷歌领头创新的一个「反垃圾链接」的标签，并被百度、yahoo 等各大搜索引擎广泛支持，引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-nofollow --save</span><br></pre></td></tr></table></figure><p>再在 hexo 根目录的<code>_config.yml</code> 中添加配置，将 <code>nofollow</code> 设置为 <code>true</code>：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nofollow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这样，例外的链接将不会被加上 <code>nofollow</code> 属性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.juanertu.com/archives/9013c8d8.html">Hexo 框架 (六)：SEO 优化及站点被搜索引擎收录设置 | 你真是一个美好的人类 (juanertu.com)</a></p><p><a href="https://qmike.top/posts/2a1b5a62">Butterfly 进阶篇（一） - SEO 优化搜索引擎收录 | 悠悠の哉 (qmike.top)</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索引擎收录 </tag>
            
            <tag> hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux添加动态库搜索路径</title>
      <link href="/posts/cf8e0b0/"/>
      <url>/posts/cf8e0b0/</url>
      
        <content type="html"><![CDATA[<h2 id="方法1：使用-export-命令：-在终端中执行以下命令，将内容添加到当前会话的环境变量中："><a href="#方法1：使用-export-命令：-在终端中执行以下命令，将内容添加到当前会话的环境变量中：" class="headerlink" title="方法1：使用 export 命令： 在终端中执行以下命令，将内容添加到当前会话的环境变量中："></a>方法1：<strong>使用 export 命令：</strong> 在终端中执行以下命令，将内容添加到当前会话的环境变量中：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/lib:<span class="variable">$LD_LIBRARY_PATH</span> </span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p><code>LD_LIBRARY_PATH</code>代表共享库搜索路径</p><p>请注意，此方法仅在当前会话中有效，关闭终端后会失效。</p><h2 id="方法2：修改用户的-bashrc文件"><a href="#方法2：修改用户的-bashrc文件" class="headerlink" title="方法2：修改用户的 .bashrc文件"></a>方法2：<strong>修改用户的 .bashrc文件</strong></h2><p>只对当前用户生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">在文件的末尾添加类似下面的行：</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/local/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">保存文件并退出编辑器。</span><br><span class="line">重新启动终端会话或执行以下命令使更改生效：</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">这样，添加的环境变量将在每次登录时自动应用。</span><br></pre></td></tr></table></figure><h2 id="方法3：修改全局的-etc-profile文件"><a href="#方法3：修改全局的-etc-profile文件" class="headerlink" title="方法3：修改全局的/etc/profile文件"></a>方法3：修改全局的/etc/profile文件</h2><p>对所有用户生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile </span><br><span class="line"><span class="built_in">export</span>  LD_LIBRARY_PATH=/usr/local/lib64:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="方法4：修改-etc-ld-so-conf文件"><a href="#方法4：修改-etc-ld-so-conf文件" class="headerlink" title="方法4：修改/etc/ld.so.conf文件"></a>方法4：修改/etc/ld.so.conf文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br><span class="line"><span class="comment">#添加要搜索的目录</span></span><br><span class="line"><span class="comment">#执行下面语句可以生效</span></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 动态库路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加快访问 GitHub 的速度</title>
      <link href="/posts/a8afb3d9/"/>
      <url>/posts/a8afb3d9/</url>
      
        <content type="html"><![CDATA[<p>随着开源项目的日益流行，越来越多的人选择在 GitHub 上托管和协作代码。然而，对于中国用户来说，由于<a href="https://cloud.baidu.com/product/et.html">网络</a>环境和地理位置的原因，访问 GitHub 可能会遇到速度慢的问题。本文将介绍几种解决方案来加快访问 GitHub 的速度。</p><h2 id="一、使用-GitHub-镜像"><a href="#一、使用-GitHub-镜像" class="headerlink" title="一、使用 GitHub 镜像"></a>一、使用 GitHub 镜像</h2><p>GitHub 镜像站是另一种加速访问 GitHub 的方式。镜像站会将 GitHub 的内容复制到本地，并提供了与 GitHub 相同的 API 服务。这样，用户就可以通过镜像站来访问 GitHub，避免了跨国网络传输的延迟。常用的 GitHub 镜像站包括：</p><ol><li>中国科学院计算机网络信息中心提供的 GitHub 镜像站（<a href="http://mirror.github.com">http://mirror.github.com</a>/)</li><li>清华大学提供的 TUNA Mirror（<a href="https://mirror.tuna.tsinghua.edu.cn/">https://mirror.tuna.tsinghua.edu.cn/</a>使用镜像站的步骤很简单，只需要在克隆或下载代码时将 URL 更换为对应的镜像站地址即可。</li></ol><h2 id="二、利用代理服务器"><a href="#二、利用代理服务器" class="headerlink" title="二、利用代理服务器"></a>二、利用代理服务器</h2><p> 代理服务器可以帮助用户绕过网络瓶颈，提高访问速度。有许多可用的代理服务器可供选择，例如 SOCKS5 代理和 HTTP 代理。在使用代理服务器时，只需将网络连接的代理地址设置为可用的代理服务器地址，即可通过代理服务器访问 GitHub。</p><h2 id="三、优化网络环境"><a href="#三、优化网络环境" class="headerlink" title="三、优化网络环境"></a>三、优化网络环境</h2><p>优化网络环境可以从多个方面入手，包括网络配置、路由器设置等。例如，在 Windows 系统中，可以通过修改 hosts 文件来指定特定的 IP 地址对应 GitHub 的<a href="https://cloud.baidu.com/product/bcd.html">域名</a>，从而加快访问速度。此外，更换更快速、更稳定的路由器和网络连接方式也能提高访问速度。</p><h2 id="四、使用-VPN-或其他网络加速工具"><a href="#四、使用-VPN-或其他网络加速工具" class="headerlink" title="四、使用 VPN 或其他网络加速工具"></a>四、使用 VPN 或其他网络加速工具</h2><p> VPN（虚拟私人网络）和其他网络加速工具可以帮助用户提高网络访问速度。VPN 可以将用户连接到更近的服务器或更快的网络环境，从而加快访问速度。一些知名的 VPN 服务提供商包括 ExpressVPN、NordVPN 和 Surfshark。此外，还有一些专门针对访问 GitHub 进行优化的工具，如 GitMate、Gitee Pro 等。</p><p>也可以使用clash，v2ray等软件。</p><p>需要注意的是，使用 VPN 或其他网络加速工具可能会带来额外的<a href="https://cloud.baidu.com/solution/security/soc.html">安全</a>风险。因此，在选择服务提供商时，请确保其具有较好的声誉和安全性。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux cpu性能测试</title>
      <link href="/posts/31cd68fa/"/>
      <url>/posts/31cd68fa/</url>
      
        <content type="html"><![CDATA[<h2 id="sysbench基础知识"><a href="#sysbench基础知识" class="headerlink" title="sysbench基础知识"></a>sysbench基础知识</h2><p>sysbench的cpu测试是在指定时间内，循环进行素数计算</p><blockquote><p>素数（也叫质数）就是从1开始的自然数中，无法被整除的数，比如2、3、5、7、11、13、17等。<br>编程公式：对正整数n，如果用2到根号n之间的所有整数去除，均无法整除，则n为素数。</p></blockquote><h2 id="sysbench安装"><a href="#sysbench安装" class="headerlink" title="sysbench安装"></a>sysbench安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># CentOS7下可使用yum安装</span><br><span class="line">yum install sysbench</span><br><span class="line"></span><br><span class="line">#ubuntu安装</span><br><span class="line">sudo apt install sysbench</span><br></pre></td></tr></table></figure><h2 id="CPU压测命令"><a href="#CPU压测命令" class="headerlink" title="CPU压测命令"></a>CPU压测命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#素数上限2万，默认10秒</span><br><span class="line">sysbench cpu --cpu-max-prime=20000 --threads=8 run</span><br><span class="line">sysbench cpu --cpu-max-prime=20000 --threads=1 run  #默认是单线程</span><br></pre></td></tr></table></figure><h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p><strong>—cpu-max-prime</strong>: 素数生成数量的上限</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 若设置为3，则表示2、3、5（这样要计算1-5共5次）</span><br><span class="line">- 若设置为10，则表示2、3、5、7、11、13、17、19、23、29（这样要计算1-29共29次）</span><br><span class="line">- 默认值为10000</span><br></pre></td></tr></table></figure><p><strong>—threads</strong>: 线程数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 若设置为1，则sysbench仅启动1个线程进行素数的计算</span><br><span class="line">- 若设置为2，则sysbench会启动2个线程，同时分别进行素数的计算</span><br><span class="line">- 默认值为1</span><br></pre></td></tr></table></figure><p><strong>—time</strong>: 运行时长，单位秒</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 若设置为5，则sysbench会在5秒内循环往复进行素数计算，</span><br><span class="line">  从输出结果可以看到在5秒内完成了几次，</span><br><span class="line">  比如配合--cpu-max-prime=3，则表示第一轮算得3个素数，</span><br><span class="line">  如果时间还有剩就再进行一轮素数计算，直到时间耗尽。</span><br><span class="line">  每完成一轮就叫一个event</span><br><span class="line">- 默认值为10</span><br><span class="line">- 相同时间，比较的是谁完成的event多</span><br></pre></td></tr></table></figure><p><strong>—events</strong>: event上限次数</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 若设置为100，则表示当完成100次event后，即使时间还有剩，也停止运行</span><br><span class="line">- 默认值为0，则表示不限event次数</span><br><span class="line">- 相同event次数，比较的是谁用时更少</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><h5 id="8核心-13700-ubuntu虚拟机"><a href="#8核心-13700-ubuntu虚拟机" class="headerlink" title="8核心 13700  ubuntu虚拟机"></a>8核心 13700  ubuntu虚拟机</h5><p>多核110598</p><p>单核13824</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">110598-8核心</span><br><span class="line"></span><br><span class="line">sysbench 1.0.20 (using system LuaJIT 2.1.0-beta3)</span><br><span class="line"></span><br><span class="line">Running the test with following options:</span><br><span class="line">Number of threads: 8 //运行线程数8</span><br><span class="line">Initializing random number generator from current time</span><br><span class="line"></span><br><span class="line">Prime numbers limit: 20000  // 每个线程产生的素数上限均为20000个</span><br><span class="line"></span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">CPU speed:</span><br><span class="line">    events per second: 11058.04 // 所有线程每秒完成了11058次event</span><br><span class="line"></span><br><span class="line">General statistics:</span><br><span class="line">    total time:                          10.0007s</span><br><span class="line">    total number of events:              110598 // 10秒内所有线程一共完成了110598次event</span><br><span class="line"></span><br><span class="line">Latency (ms):</span><br><span class="line">         min:                                    0.60</span><br><span class="line">         avg:                                    0.72</span><br><span class="line">         max:                                    6.90</span><br><span class="line">         95th percentile:                        0.81</span><br><span class="line">         sum:                                79972.90</span><br><span class="line"></span><br><span class="line">Threads fairness:</span><br><span class="line">    events (avg/stddev):           13824.7500/89.70// 平均每个线程完成13824次event，标准差为89.70</span><br><span class="line">    execution time (avg/stddev):   9.9966/0.00 // 每个线程平均耗时10秒，标准差为0</span><br></pre></td></tr></table></figure><h5 id="jecson-4核心arm"><a href="#jecson-4核心arm" class="headerlink" title="jecson 4核心arm"></a>jecson 4核心arm</h5><p>4核心18395</p><p>单核 2299</p><p>可以看出13700 的8个大核心是jecson的性能的5-10倍</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/56889337">linux sysbench: CPU性能测试详解 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能测试 </tag>
            
            <tag> jecson </tag>
            
            <tag> 13700 </tag>
            
            <tag> sysbench </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux和windows共享文件夹</title>
      <link href="/posts/a059173d/"/>
      <url>/posts/a059173d/</url>
      
        <content type="html"><![CDATA[<h3 id="ubuntu访问windows"><a href="#ubuntu访问windows" class="headerlink" title="ubuntu访问windows"></a>ubuntu访问windows</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t cifs //10.170.27.210/ ~/share -o username=&#x27;***@qq.com&#x27;,password=&#x27;***&#x27;,vers=2.0</span><br><span class="line"></span><br><span class="line">sudo busybox  mount -t cifs //10.170.27.210/topographic_map ~/share -o username=***@qq.com,password=***,vers=2.0</span><br></pre></td></tr></table></figure><h3 id="windows访问ubuntu"><a href="#windows访问ubuntu" class="headerlink" title="windows访问ubuntu"></a>windows访问ubuntu</h3><h4 id="确认系统中安装samba"><a href="#确认系统中安装samba" class="headerlink" title="确认系统中安装samba"></a>确认系统中安装samba</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba</span><br></pre></td></tr></table></figure><h4 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd xdsmb -g  6000</span><br><span class="line">sudo useradd  xdsmb -u 6000 -g 6000 -s /sbin/nologin -d /dev/null</span><br></pre></td></tr></table></figure><h4 id="设置你的账户samba密码"><a href="#设置你的账户samba密码" class="headerlink" title="设置你的账户samba密码"></a>设置你的账户samba密码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /etc/samba/smbpasswd</span><br><span class="line">sudo smbpasswd -a xdsmb    #usr 表示你的用户名</span><br></pre></td></tr></table></figure><p>然后按照提示输入密码就可以了。</p><p>密码 <em>*</em></p><h4 id="将你的用户添加到sambashare用户组中"><a href="#将你的用户添加到sambashare用户组中" class="headerlink" title="将你的用户添加到sambashare用户组中"></a>将你的用户添加到sambashare用户组中</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser xdsmb sambashare</span><br></pre></td></tr></table></figure><h4 id="具体共享文件方法"><a href="#具体共享文件方法" class="headerlink" title="具体共享文件方法"></a>具体共享文件方法</h4><p>右击你想共享的文件夹，点击本地网络共享，然后点击共享文件夹就可以了。</p><h4 id="怎么在Windows中访问这个共享文件夹"><a href="#怎么在Windows中访问这个共享文件夹" class="headerlink" title="怎么在Windows中访问这个共享文件夹"></a>怎么在Windows中访问这个共享文件夹</h4><p>方法跟Windows访问Windows是一样的，按Windows+R，然后输入</p><h4 id="命令行配置共享文件夹"><a href="#命令行配置共享文件夹" class="headerlink" title="命令行配置共享文件夹"></a>命令行配置共享文件夹</h4><p><a href="https://blog.csdn.net/lantian6/article/details/107250008">ubuntu命令行配置文件夹共享_重启ubuntu共享问价夹命令-CSDN博客</a></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h5 id="Ubuntu挂载nfs文件系统报错：mount-mnt-nfs-bad-option-for-several-filesystems-e-g-nfs-cifs-you-might-need-a-sbin-mount-helper-program-。"><a href="#Ubuntu挂载nfs文件系统报错：mount-mnt-nfs-bad-option-for-several-filesystems-e-g-nfs-cifs-you-might-need-a-sbin-mount-helper-program-。" class="headerlink" title="Ubuntu挂载nfs文件系统报错：mount: /mnt/nfs: bad option; for several filesystems (e.g. nfs, cifs) you might need a /sbin/mount. helper program.。"></a><a href="https://so.csdn.net/so/search?q=Ubuntu&amp;spm=1001.2101.3001.7020">Ubuntu</a>挂载nfs文件系统报错：mount: /mnt/nfs: bad option; for several filesystems (e.g. nfs, cifs) you might need a /sbin/mount.<type> helper program.。</h5><p><a href="https://blog.csdn.net/weixin_43782998/article/details/109788521">高版本Ubuntu挂载nfs文件系统报错：mount: /mnt/nfs: bad option； for several filesystems (e.g. nfs, cifs)_bad option; for several filesystems (e.g. nfs, cif-CSDN博客</a></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://blog.csdn.net/rangfei/article/details/124225799#:~:text=3.1 Ubuntu 下设置共享目录 1 对要共享的目录右击 -&gt; Local Network,2 选择Share this folder 3 安装共享服务 GUI方式安装 提示安装samba包">Ubuntu：与Windows共享文件夹_ubuntu访问windows共享文件夹-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> windows </tag>
            
            <tag> 共享文件夹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux修改环境变量</title>
      <link href="/posts/e0ce2883/"/>
      <url>/posts/e0ce2883/</url>
      
        <content type="html"><![CDATA[<p>要将内容添加到 Linux 环境变量中，可以通过以下几种方法进行操作：</p><ol><li><p><strong>使用 export 命令：</strong> 在终端中执行以下命令，将内容添加到当前会话的环境变量中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> VARIABLE_NAME=<span class="string">&quot;value&quot;</span></span><br><span class="line"></span><br><span class="line">将 `VARIABLE_NAME` 替换为要添加的环境变量的名称，将 `<span class="string">&quot;value&quot;</span>` 替换为要设置的值。</span><br><span class="line">例如，要将 `/path/to/directory` 添加到 `PATH` 环境变量中，可以执行以下命令：</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/path/to/directory:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line">这将把 `/path/to/directory` 添加到 `PATH` 变量的开头，保留原有的 `PATH` 值。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请注意，此方法仅在当前会话中有效，关闭终端后会失效。</p></li><li><p><strong>修改用户的 .bashrc 或 .bash_profile 文件：</strong> 如果要将内容添加到特定用户的环境变量中，并在每次登录时自动应用，可以编辑用户的 <code>.bashrc</code> 或 <code>.bash_profile</code> 文件。这些文件位于用户的主目录下。</p><p>打开终端，并使用文本编辑器（如 <code>vi</code> 或 <code>nano</code>）打开 <code>.bashrc</code> 或 <code>.bash_profile</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">在文件的末尾添加类似下面的行：</span><br><span class="line"><span class="built_in">export</span> PATH=/home/book/cmake-3.26.0-rc6-linux-x86_64/bin:/home/cs18/vcpkg:<span class="variable">$PATH</span></span><br><span class="line">保存文件并退出编辑器。</span><br><span class="line">重新启动终端会话或执行以下命令使更改生效：</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">这样，添加的环境变量将在每次登录时自动应用。</span><br></pre></td></tr></table></figure></li><li><p><strong>修改全局的 /etc/profile  文件：</strong> 如果要在整个系统范围内添加环境变量，可以编辑 <code>/etc/profile</code> 文件（需要管理员权限）。</p><p>打开终端，并使用管理员权限打开 <code>/etc/profile</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile </span><br><span class="line">在文件中最下面添加类似下面的行：</span><br><span class="line">PATH=<span class="string">&quot;<span class="variable">$PATH</span>:/usr/local/sbin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后执行下面命令就可以生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li></ol><p>请根据您的需求选择适当的方法，并根据需要设置相应的环境变量。请注意，添加环境变量后，它们将在适当的上下文中可用，并对相关的应用程序生效。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 环境变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客需要自定义的地方</title>
      <link href="/posts/e7df18ca/"/>
      <url>/posts/e7df18ca/</url>
      
        <content type="html"><![CDATA[<p>待写</p><h2 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h2><h2 id="背景图"><a href="#背景图" class="headerlink" title="背景图"></a>背景图</h2><h2 id="留言板"><a href="#留言板" class="headerlink" title="留言板"></a>留言板</h2><h2 id="搜索引擎优化"><a href="#搜索引擎优化" class="headerlink" title="搜索引擎优化"></a>搜索引擎优化</h2><p><a href="https://jinianyoushang.github.io/posts/e302e79f/">Butterfly优化搜索引擎收录 | xd’s blog (jinianyoushang.github.io)</a></p><h2 id="为-Github-Pages-绑定域名"><a href="#为-Github-Pages-绑定域名" class="headerlink" title="为 Github Pages 绑定域名"></a>为 Github Pages 绑定域名</h2><p><a href="https://cometeme.github.io/web/2018/08/为GitHubPages绑定域名.html#:~:text=使用自己的域名来访问博客 1 1. 修改 DNS 解析的数据 在设置 Github,Using a custom domain with GitHub Pages 。">为 Github Pages 绑定域名 - cometeme的个人博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>生成 SSH 密钥（windows+liunx）</title>
      <link href="/posts/e253486a/"/>
      <url>/posts/e253486a/</url>
      
        <content type="html"><![CDATA[<h1 id="生成-SSH-密钥（windows-liunx）"><a href="#生成-SSH-密钥（windows-liunx）" class="headerlink" title="生成 SSH 密钥（windows+liunx）"></a>生成 SSH 密钥（windows+liunx）</h1><h2 id="要在-Windows-10-上生成-SSH-密钥，您可以按照以下步骤操作："><a href="#要在-Windows-10-上生成-SSH-密钥，您可以按照以下步骤操作：" class="headerlink" title="要在 Windows 10 上生成 SSH 密钥，您可以按照以下步骤操作："></a><strong>要在 Windows 10 上生成 SSH 密钥，您可以按照以下步骤操作：</strong></h2><p>1.打开 PowerShell（或者按下 Windows + X 并选择 “Windows PowerShell”）；</p><p>2.在 PowerShell 中输入以下命令来生成 SSH 密钥：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>3.输入您要保存密钥文件的路径和名称。例如：C:\Users\YourName.ssh\id_rsa。您可以选择保留默认名称，因为它已经被 SSH 所识别（id_rsa）；</p><p>4.在弹出的窗口中输入密码，或者直接敲击回车键选择不设置密码；</p><p>5.这个时候，您会得到一个公共密钥（id_rsa.pub）和一个私有密钥（id_rsa）。</p><p>现在您已经成功地生成了 SSH 密钥对。公钥是要提供给远程服务器的，私钥则要保留在本地，并加以保护。</p><h2 id="在-Linux-上生成-SSH-密钥的步骤与在-Windows-上类似。您可以按照以下步骤操作："><a href="#在-Linux-上生成-SSH-密钥的步骤与在-Windows-上类似。您可以按照以下步骤操作：" class="headerlink" title="在 Linux 上生成 SSH 密钥的步骤与在 Windows 上类似。您可以按照以下步骤操作："></a><strong>在 Linux 上生成 SSH 密钥的步骤与在 Windows 上类似。您可以按照以下步骤操作：</strong></h2><p>1.打开终端（或者按下 Ctrl + Alt + T）；</p><p>2.输入以下命令来生成 SSH 密钥：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>3.输入您要保存密钥文件的路径和名称，或者直接敲击回车键选择默认值，例如：/home/YourName/.ssh/id_rsa；</p><p>4.在弹出的窗口中输入密码，或者直接敲击回车键选择不设置密码；</p><p>5.这个时候，您会得到一个公共密钥（id_rsa.pub）和一个私有密钥（id_rsa）。</p><p>现在您已经成功地生成了 SSH 密钥对。公钥是要提供给远程服务器的，私钥则要保留在本地，并加以保护。另外，如果您想要让 SSH 代理管理您的密钥，您还需要在本地配置 SSH 代理。</p>]]></content>
      
      
      <categories>
          
          <category> ssh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACG</title>
      <link href="/posts/5665/"/>
      <url>/posts/5665/</url>
      
        <content type="html"><![CDATA[<div class="gallery-group-main"><figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://bu.dusays.com/2022/11/26/638228a86935a.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">ACG</div>  <p>那些二次元的故事</p>  <a href='/gallery/ACG'></a>  </figcaption>  </figure>  </div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>综合测试</title>
      <link href="/posts/39097/"/>
      <url>/posts/39097/</url>
      
        <content type="html"><![CDATA[<h3 id="测试代码显示"><a href="#测试代码显示" class="headerlink" title="测试代码显示"></a>测试代码显示</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Buffer2D&lt;Float3&gt; <span class="title">Denoiser::Filter</span><span class="params">(<span class="type">const</span> FrameInfo &amp;frameInfo)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> height = frameInfo.m_beauty.m_height;</span><br><span class="line">    <span class="type">int</span> width = frameInfo.m_beauty.m_width;</span><br><span class="line">    Buffer2D&lt;Float3&gt; filteredImage = <span class="built_in">CreateBuffer2D</span>&lt;Float3&gt;(width, height);</span><br><span class="line">    <span class="type">int</span> kernelRadius = <span class="number">32</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; width; x++) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Joint bilateral filter</span></span><br><span class="line">            <span class="comment">// filteredImage(x, y) = frameInfo.m_beauty(x, y);</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> x_start = std::<span class="built_in">max</span>(<span class="number">0</span>, x - kernelRadius);</span><br><span class="line">            <span class="type">int</span> x_end = std::<span class="built_in">min</span>(width - <span class="number">1</span>, x + kernelRadius);</span><br><span class="line">            <span class="type">int</span> y_start = std::<span class="built_in">max</span>(<span class="number">0</span>, y - kernelRadius);</span><br><span class="line">            <span class="type">int</span> y_end = std::<span class="built_in">min</span>(height - <span class="number">1</span>, y + kernelRadius);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> center_postion = frameInfo.<span class="built_in">m_position</span>(x, y);</span><br><span class="line">            <span class="keyword">auto</span> center_normal = frameInfo.<span class="built_in">m_normal</span>(x, y);</span><br><span class="line">            <span class="keyword">auto</span> center_color = frameInfo.<span class="built_in">m_beauty</span>(x, y);</span><br><span class="line"></span><br><span class="line">            Float3 final_color;</span><br><span class="line">            <span class="keyword">auto</span> total_weight = <span class="number">.0</span>f;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = x_start; m &lt;= x_end; m++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> n = y_start; n &lt;= y_end; n++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">auto</span> postion = frameInfo.<span class="built_in">m_position</span>(m, n);</span><br><span class="line">                    <span class="keyword">auto</span> normal = frameInfo.<span class="built_in">m_normal</span>(m, n);</span><br><span class="line">                    <span class="keyword">auto</span> color = frameInfo.<span class="built_in">m_beauty</span>(m, n);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">auto</span> d_position = <span class="built_in">SqrDistance</span>(center_postion, postion) /</span><br><span class="line">                                      (<span class="number">2.0f</span> * m_sigmaCoord * m_sigmaCoord);</span><br><span class="line">                    <span class="keyword">auto</span> d_color = <span class="built_in">SqrDistance</span>(center_color, color) /</span><br><span class="line">                                   (<span class="number">2.0f</span> * m_sigmaColor * m_sigmaColor);</span><br><span class="line">                    <span class="keyword">auto</span> d_normal = <span class="built_in">SafeAcos</span>(<span class="built_in">Dot</span>(center_normal, normal));</span><br><span class="line">                    d_normal *= d_normal;</span><br><span class="line">                    d_normal / (<span class="number">2.0f</span> * m_sigmaNormal * m_sigmaNormal);</span><br><span class="line"></span><br><span class="line">                    <span class="type">float</span> d_plane = <span class="number">.0</span>f;</span><br><span class="line">                    <span class="keyword">if</span> (d_position &gt; <span class="number">0.f</span>) &#123;</span><br><span class="line">                        d_plane = <span class="built_in">Dot</span>(center_normal, <span class="built_in">Normalize</span>(postion - center_postion));</span><br><span class="line">                    &#125;</span><br><span class="line">                    d_plane *= d_plane;</span><br><span class="line">                    d_plane /= (<span class="number">2.0f</span> * m_sigmaPlane * m_sigmaPlane);</span><br><span class="line"></span><br><span class="line">                    <span class="type">float</span> weight = std::<span class="built_in">exp</span>(-d_plane - d_position - d_color - d_normal);</span><br><span class="line">                    total_weight += weight;</span><br><span class="line">                    final_color += color * weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">filteredImage</span>(x, y) = final_color / total_weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filteredImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试公式"><a href="#测试公式" class="headerlink" title="测试公式"></a>测试公式</h3><script type="math/tex; mode=display">a+b=c</script><h3 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h3><p>hexo图片引用方式有三种,推荐使用第二种方式，并在开头加上 <code>typora-root-url:&#123;title&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img test.png 图片引用方法一 %&#125;</span><br><span class="line"></span><br><span class="line">![图片引用方法二](test.png)</span><br><span class="line"></span><br><span class="line">![图片引用方法三](./images/test.png)</span><br></pre></td></tr></table></figure><p>如下</p><img src="/posts/39097/test.png" class="" title="图片引用方法一"><p><img src="test.png" alt="图片引用方法二"></p><p><img src="%25E6%25B5%258B%25E8%25AF%2595%25E5%259B%25BE%25E7%2589%2587/test.png" alt="图片引用方法三"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>firstc++</title>
      <link href="/posts/44e603ce/"/>
      <url>/posts/44e603ce/</url>
      
        <content type="html"><![CDATA[<p>这个是测试文件</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages+Hexo+Fluid搭建个人博客网站</title>
      <link href="/posts/41067/"/>
      <url>/posts/41067/</url>
      
        <content type="html"><![CDATA[<h2 id="GitHub-Pages-Hexo-Fluid搭建个人博客网站"><a href="#GitHub-Pages-Hexo-Fluid搭建个人博客网站" class="headerlink" title="GitHub Pages+Hexo+Fluid搭建个人博客网站"></a>GitHub Pages+Hexo+Fluid搭建个人博客网站</h2><p>本文介绍如何使用GitHub Pages + Hexo搭建个人博客网站，完全免费，所有内容本人亲测，绝对可用。</p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><ol><li><h4 id="GitHub账号"><a href="#GitHub账号" class="headerlink" title="GitHub账号"></a>GitHub账号</h4><p>需要有一个GitHub账号，没有的话到 官网 申请一个。<br>注册很简单，不懂的话可以参考 GitHub申请账号</p></li><li><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>在自己电脑上安装好Git，hexo部署到GitHub时要用。<br>网上找篇教程或者参考 Git安装(Windows)</p></li><li><h4 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h4><p>在自己电脑上安装好NodeJS，Hexo是基于NodeJS编写的，所以需要安装NodeJS和npm工具。<br>网上找篇教程或者参考 NodeJS安装及配置(Windows)</p></li></ol><h2 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h2><p>  在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>  点击<code>Your repositories</code>，进入仓库页面。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70.png" alt="请添加图片描述"></p><p>点击<code>New</code>按钮，进入仓库创建页面。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-17097312466013.png" alt="请添加图片描述"></p><p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-17097312600136.png" alt="请添加图片描述"></p><p>点击<code>creating a new file</code>创建一个新文件，作为我们网站的主页。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-17097312711059.png" alt="请添加图片描述"></p><p>浏览器中访问，展示成功。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973177563416.png" alt="请添加图片描述"></p><p>这里创建的网页是非常简陋的，只是为了演示下<code>GitHub Pages</code>的使用方式。</p><h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>我们采用Hexo来创建我们的博客网站，Hexo 是一个基于NodeJS的静态博客网站生成器，使用Hexo不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 官网。</p><p>安装 Hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>创建一个项目 hexo-blog 并初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo-blog</span><br><span class="line"><span class="built_in">cd</span> hexo-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>本地启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p><strong>浏览器访问 <a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a></strong></p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973190888219.png" alt="请添加图片描述"></p><h2 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h2><p><code>Hexo</code> 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点 <a href="https://hexo.io/themes/">这里</a> 查看。这里介绍两个主题的使用方法，<code>Next</code> 和 <code>Fluid</code>，个人比较喜欢<code>Fluid</code>，后面章节的功能也是以 <code>Fluid</code> 为基础进行讲解的。</p><h3 id="1-NexT-主题"><a href="#1-NexT-主题" class="headerlink" title="1. NexT 主题"></a>1. NexT 主题</h3><p><strong>安装主题</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hexo-blog</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p><strong>使用 NexT 主题</strong></p><p>打开 _config.yml 文件，该文件为站点配置文件</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973199073122.png" alt="请添加图片描述"></p><p>将主题修改为 next</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p><strong>本地启动</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h3 id="2-Fluid主题"><a href="#2-Fluid主题" class="headerlink" title="2. Fluid主题"></a>2. Fluid主题</h3><p>以下安装步骤摘自 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></p><p><strong>安装主题</strong></p><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><p><strong>指定主题</strong></p><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">theme: fluid  # 指定主题</span><br><span class="line">language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改</span><br></pre></td></tr></table></figure><p><strong>创建「关于页」</strong></p><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line">date: 2020-02-23 19:20:33</span><br><span class="line">layout: about</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这里写关于页的正文，支持 Markdown, HTML</span><br></pre></td></tr></table></figure><p><strong>本地启动</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000">http://localhost:4000</a> ，<code>Fluid</code>主题风格页面如下</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973216615825.png" alt="请添加图片描述"></p><h2 id="五、创建文章"><a href="#五、创建文章" class="headerlink" title="五、创建文章"></a>五、创建文章</h2><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>执行如下命令创建一篇新文章，名为《测试文章》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post 测试文章</span><br></pre></td></tr></table></figure><p>执行完成后在<code>source\_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)</p><p><img src="4d471824356e476e8c8e092caa453f8a.png" alt="请添加图片描述"></p><p>在资源目录<code>测试文章</code>中放一张图片 <code>test.png</code></p><p><img src="96a7534cb7a743438c553298b216b8b0.png" alt="请添加图片描述"></p><p>在<code>测试文章.md</code>中添加内容如下，演示了图片的三种引用方式。第一种为官方推荐用法，第二种为markdown语法，第三种和前两种图片存放位置不一样，是将图片放在<code>\source\images</code>目录下。这三种写法在md文件中图片是无法显示的，但是在页面上能正常显示。</p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html，有详细介绍。">https://hexo.io/zh-cn/docs/asset-folders.html，有详细介绍。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 测试文章</span><br><span class="line">date: 2021-06-10 16:35:20</span><br><span class="line">tags:</span><br><span class="line">- 原创</span><br><span class="line">categories:</span><br><span class="line">- Java</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">这是一篇测试文章</span><br><span class="line"></span><br><span class="line">&#123;% asset_img test.png 图片引用方法一 %&#125;</span><br><span class="line"></span><br><span class="line">![图片引用方法二](test.png)</span><br><span class="line"></span><br><span class="line">![图片引用方法三](images/test.png)</span><br></pre></td></tr></table></figure><p><strong>本地启动</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="http://localhost:4000，页面如下，文章添加成功">http://localhost:4000，页面如下，文章添加成功</a></p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973235097232.png" alt="请添加图片描述"></p><h2 id="六、个性化页面展示"><a href="#六、个性化页面展示" class="headerlink" title="六、个性化页面展示"></a>六、个性化页面展示</h2><p>页面的标题等位置显示默认的文字，可以改下显示一些个性化的信息。</p><h3 id="1-浏览器tab页名称"><a href="#1-浏览器tab页名称" class="headerlink" title="1. 浏览器tab页名称"></a>1. 浏览器tab页名称</h3><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973237506635.png" alt="请添加图片描述"></p><h3 id="2-博客标题"><a href="#2-博客标题" class="headerlink" title="2. 博客标题"></a>2. 博客标题</h3><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973240546038.png" alt="请添加图片描述"></p><h3 id="3-主页正中间的文字"><a href="#3-主页正中间的文字" class="headerlink" title="3. 主页正中间的文字"></a>3. 主页正中间的文字</h3><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973242297441.png" alt="请添加图片描述"></p><p>修改好配置后，页面效果如下，可以看到现在显示的内容变成了我们的个人信息。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973243621044.png" alt="请添加图片描述"></p><h2 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h2><p><code>Fluid</code> 主题写好了统计阅读量的代码，但是缺少相应配置所以没有开启，需要借助三方服务来统计阅读量，这里是有 <code>Leancloud</code> 的免费服务来进行统计。</p><h3 id="1-申请LeanCloud账号并创建应用"><a href="#1-申请LeanCloud账号并创建应用" class="headerlink" title="1. 申请LeanCloud账号并创建应用"></a>1. 申请LeanCloud账号并创建应用</h3><p>进入 <a href="https://console.leancloud.cn/">官网</a> 注册账号</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973245991647.png" alt="请添加图片描述"></p><p>需实名认证，完成后才能使用各项服务</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973248355150.png" alt="请添加图片描述"></p><p>验证邮箱</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973249360553.png" alt="请添加图片描述"></p><p>创建应用，选择<code>开发版</code>即可，免费的</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973251024756.png" alt="请添加图片描述"></p><p>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973252709559.png" alt="请添加图片描述"></p><h3 id="2-修改Fluid配置"><a href="#2-修改Fluid配置" class="headerlink" title="2. 修改Fluid配置"></a>2. 修改Fluid配置</h3><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><p><strong>单篇文章阅读量计数</strong></p><p>打开统计开关</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973254863762.png" alt="请添加图片描述"></p><p>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code></p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973256435465.png" alt="请添加图片描述"></p><p>打开计数功能，统计来源改为 <code>leancloud</code></p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973257710768.png" alt="请添加图片描述"></p><p>页面效果</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973258722771.png" alt="请添加图片描述"></p><p>页面底部展示网站的 PV、UV 统计数</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973259582274.png" alt="请添加图片描述"></p><p>页面效果</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973260379677.png" alt="请添加图片描述"></p><h2 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h2><p>评论功能的代码已经写好了，只不过没有开启，需要修改一些配置</p><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><p>启用评论插件</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973263277980.png" alt="请添加图片描述"></p><p>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code></p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973263969583.png" alt="请添加图片描述"></p><p>重新部署后，查看页面效果，评论功能已开启</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973265015086.png" alt="请添加图片描述"></p><p>部署在本地时评论无法提交，会报跨域问题，发布到 <code>GitHub Pages</code> 上之后课正常提交评论</p><h2 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>安装hexo-deployer-git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改根目录下的 <code>_config.yml</code>，配置 <code>GitHub</code> 相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/yaorongke/yaorongke.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line">  token: ******************************</span><br></pre></td></tr></table></figure><p>其中 <code>token</code> 为 <code>GitHub</code> 的 <code>Personal access tokens</code>，获取方式如下图</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973269228189.png" alt="请添加图片描述"></p><p>部署到GitHub</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>浏览器访问 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a> ，部署成功</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973271472592.png" alt="请添加图片描述"></p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>直接将 <code>public</code> 目录中的文件和目录推送至 <code>GitHub</code> 仓库和分支中。</p><p><img src="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70-170973272612995.png" alt="请添加图片描述"></p><h2 id="十、发布到自己服务器，Nginx代理"><a href="#十、发布到自己服务器，Nginx代理" class="headerlink" title="十、发布到自己服务器，Nginx代理"></a>十、发布到自己服务器，Nginx代理</h2><p>如果自己有服务器的话，也可以不使用 GitHub Pages，直接部署的自己的服务器上，通过 Nginx 进行代理，我这里有一个阿里云上的 CentOS 7 版的 Linux 服务器，演示下如何部署，步骤如下。</p><p>打开 hexo-blog 根目录下的 _config.yml，增加如下配置，这是因为把网站存放在了子目录中，要和 Nginx 配置中的 location /blog 路径一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root: /blog</span><br></pre></td></tr></table></figure><p><code>hexo-blog</code> 根目录下执行打包命令，打包好的文件在 <code>public</code> 目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>将<code>public</code> 目录下的文件复制到 <code>Linux</code> 服务器上的某个目录下，我的存放目录为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/rkyao/fronted/hexo-blog</span><br></pre></td></tr></table></figure><p>修改 <code>Nginx</code> 配置文件，我的 <code>Nginx</code> 安装路径为 <code>/usr/local</code>，大家根据自己实际情况调整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br><span class="line">vim nginx.conf</span><br><span class="line"># server节点下添加如下配置</span><br><span class="line">location /blog &#123;</span><br><span class="line">    alias  /opt/rkyao/fronted/hexo-blog;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 <code>Nginx</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/sbin</span><br><span class="line">./nginx -s reload</span><br></pre></td></tr></table></figure><p>访问博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://47.96.106.173/blog/</span><br></pre></td></tr></table></figure><h2 id="十一、最终效果展示"><a href="#十一、最终效果展示" class="headerlink" title="十一、最终效果展示"></a>十一、最终效果展示</h2><p>可访问如下地址查看</p><p><a href="https://jinianyoushang.github.io/">https://jinianyoushang.github.io/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_hexo博客-CSDN博客</a></p><p><a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p><p><a href="https://butterfly.js.org/posts/21cfbf15/#安裝">Butterfly 安裝文檔(一) 快速開始 | Butterfly</a></p><p><a href="https://fe32.top/articles/hexo1605/#Inject">基于 Hexo 从零开始搭建个人博客（五） | 唐志远 (fe32.top)</a></p><p><a href="https://fe32.top/articles/hexo1607/#Local-search">基于 Hexo 键入搜索功能 | 唐志远 (fe32.top)</a></p><p><a href="https://console.leancloud.cn/">https://console.leancloud.cn/</a></p><p><a href="https://hexo.fluid-dev.com/docs/guide/#slogan-打字机">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p><p><a href="https://hexo.io/zh-cn/docs/asset-folders.html">资源文件夹 | Hexo</a></p><p><a href="https://connor-sun.github.io/posts/41255.html">Hexo+NexT+Typora【搭建记录&amp;使用指南】 | Connor (connor-sun.github.io)</a></p><p><a href="https://www.bilibili.com/video/BV16b4y1G7fo/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0d5feab415814c73cb3f13d1f8e7642b">Hexo+Github：个人博客的搭建_哔哩哔哩_bilibili</a></p><p><a href="https://cloud.tencent.com/developer/article/1970544">Hexo + Typora + 开发Hexo插件 解决图片路径不一致-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> githubpage </tag>
            
            <tag> next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo插入图片且网络和本地都可以显示</title>
      <link href="/posts/21241/"/>
      <url>/posts/21241/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-typora插入图片且网络和本地都可以显示"><a href="#hexo-typora插入图片且网络和本地都可以显示" class="headerlink" title="hexo+typora插入图片且网络和本地都可以显示"></a>hexo+typora插入图片且网络和本地都可以显示</h2><p>两种方法解决解决hexo插入本地图片</p><p>先hexo new “文章名”，把图片放入<code>_posts/文章名</code> 文件夹中</p><h3 id="第一种，使用官方引用图片方式"><a href="#第一种，使用官方引用图片方式" class="headerlink" title="第一种，使用官方引用图片方式"></a>第一种，使用官方引用图片方式</h3><p>这种在本地typora不会显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg [title] %&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种，使用typora-root-url-推荐"><a href="#第二种，使用typora-root-url-推荐" class="headerlink" title="第二种，使用typora-root-url,(推荐)"></a>第二种，使用<code>typora-root-url</code>,(推荐)</h3><p>如果你知道 typora-root-url 这一个 typora 特有的 Markdown Front-matter 的话你就知道怎么解决了。</p><p><strong>什么是 Front-matter？</strong></p><p>Front-matter 是 markdown 文件最上方以 —- 分隔的区域，用于指定个别档案的变数。</p><p>typora-root-url 指定了 typora 把哪里当做图片搜索的根目录，就像程序的 workspace 一样。</p><p><strong>怎么做？</strong></p><p>我们只需要设定 typora-root-url 为资源文件夹，然后在 typora 里面导入图片资源时写相对路径，typora 就会自动以 typora-root-url 为起始目录开始搜索。</p><p>举个例子：设置 typora-root-url 为 resource，在 typora 里面导入图片 img1.jpg，这个时候 typora 就会去找 resource/img1.jpg。</p><p>因为使用的是相对路径，hexo 也能很好识别。如果在 hexo 的 scaffolds 下修改 Markdown 模板就可以让 hexo 自动为你填写 typora-root-url 了</p><p>注意复制后删除图片前多余的<code>/</code>，比如<code>![](/image.jpg)</code>不对，应该是<code>![](image.jpg)</code></p><p>同时也要打开<code>_config.yml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>举个例子（post.md）：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">typora-root-url: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated:</span><br><span class="line">tags: &#123;&#123; tags &#125;&#125;</span><br><span class="line">categories: &#123;&#123; categories &#125;&#125;</span><br><span class="line">keywords: &#123;&#123; keywords &#125;&#125;</span><br><span class="line">description: &#123;&#123; description &#125;&#125;</span><br><span class="line">top<span class="emphasis">_img:</span></span><br><span class="line"><span class="emphasis">comments:</span></span><br><span class="line"><span class="emphasis">cover:</span></span><br><span class="line"><span class="emphasis">toc:</span></span><br><span class="line"><span class="emphasis">toc_</span>number:</span><br><span class="line">toc<span class="emphasis">_style_</span>simple:</span><br><span class="line">copyright:</span><br><span class="line">copyright<span class="emphasis">_author:</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href:</span></span><br><span class="line"><span class="emphasis">copyright_</span>url:</span><br><span class="line">copyright<span class="emphasis">_info:</span></span><br><span class="line"><span class="emphasis">mathjax:</span></span><br><span class="line"><span class="emphasis">katex:</span></span><br><span class="line"><span class="emphasis">aplayer:</span></span><br><span class="line"><span class="emphasis">highlight_</span>shrink:</span><br><span class="line">aside:</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>hexo 会使用文件名来替换 hexo + typora调教指南 字段。</p><h3 id="第三种，使用插件"><a href="#第三种，使用插件" class="headerlink" title="第三种，使用插件"></a>第三种，使用插件</h3><p>在本地typora可以显示</p><p><a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked </a>解决hexo插入本地图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><p>在配置文件<code>_config.yml</code>中修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:  </span><br><span class="line">  prependRoot: true  </span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>使用语法插入图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure><p>本地预览不显示图片的问题</p><p>在typora的设置中选择图片工具，选择格式-&gt;图像-&gt;设置图像根目录 ，到图像存放目录即可</p><p><img src="v2-8d28ac51aedad913907c45b4907d325f_720w.webp" alt="img"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://hexo.io/zh-cn/docs/asset-folders.html">资源文件夹 | Hexo</a></p><p><a href="https://blog.notnotype.com/2023/02/28/hexo-typora的博客体验/">hexo + typora调教指南 | Notype 的博客 (notnotype.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo 插入图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的开头</title>
      <link href="/posts/51718/"/>
      <url>/posts/51718/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">typora-root-url: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">cover: </span><br><span class="line">top_img: </span><br><span class="line">tags: </span><br><span class="line">- &#123;&#123; tags &#125;&#125;</span><br><span class="line">categories: </span><br><span class="line">- &#123;&#123; categories &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">typora-root-url: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">cover: </span><br><span class="line">top_img: </span><br><span class="line">tags: </span><br><span class="line">- &#123;&#123; tags &#125;&#125;</span><br><span class="line">categories: </span><br><span class="line">- &#123;&#123; categories &#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> tags </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试图片</title>
      <link href="/posts/50266/"/>
      <url>/posts/50266/</url>
      
        <content type="html"><![CDATA[<h3 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h3><p>hexo图片引用方式有三种,推荐使用第二种方式，并在开头加上 <code>typora-root-url:&#123;title&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img test.png 图片引用方法一 %&#125;</span><br><span class="line"></span><br><span class="line">![图片引用方法二](test.png)</span><br><span class="line"></span><br><span class="line">![图片引用方法三](./images/test.png)</span><br></pre></td></tr></table></figure><p>如下</p><img src="/posts/50266/test.png" class="" title="图片引用方法一"><p><img src="test.png" alt="图片引用方法二"></p><p><img src="./%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/test.png" alt="图片引用方法三"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>npm使用国内淘宝镜像的方法（两种）</title>
      <link href="/posts/30472/"/>
      <url>/posts/30472/</url>
      
        <content type="html"><![CDATA[<h3 id="一、通过命令配置"><a href="#一、通过命令配置" class="headerlink" title="一、通过命令配置"></a>一、通过命令配置</h3><h4 id="1、设置淘宝镜像源"><a href="#1、设置淘宝镜像源" class="headerlink" title="1、设置淘宝镜像源"></a>1、设置淘宝镜像源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure><h4 id="2、设置官方镜像源"><a href="#2、设置官方镜像源" class="headerlink" title="2、设置官方镜像源"></a>2、设置官方镜像源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure><h4 id="3、查看镜像使用状态："><a href="#3、查看镜像使用状态：" class="headerlink" title="3、查看镜像使用状态："></a>3、查看镜像使用状态：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>如果返回<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com/</a> ，说明配置的是淘宝镜像。</p><p>如果返回<a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> ，说明配置的是官方镜像。</p><h3 id="二、通过使用cnpm安装"><a href="#二、通过使用cnpm安装" class="headerlink" title="二、通过使用cnpm安装"></a>二、通过使用cnpm安装</h3><h3 id="1、安装cnpm"><a href="#1、安装cnpm" class="headerlink" title="1、安装cnpm"></a>1、安装cnpm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> npm install -g cnpm --registry=https://registry.npmmirror.com</span><br><span class="line"> 解决安装卡顿或无法安装：</span><br><span class="line"></span><br><span class="line">注册模块镜像</span><br><span class="line"> npm set registry https://registry.npmmirror.com</span><br><span class="line">  // node-gyp 编译依赖的 node 源码镜像  </span><br><span class="line"> npm set disturl https://npmmirror.com/dist </span><br><span class="line"> // 清空缓存  </span><br><span class="line"> npm cache clean --force  </span><br><span class="line"> // 安装cnpm  </span><br><span class="line"> npm install -g cnpm --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><h3 id="2、使用cnpm"><a href="#2、使用cnpm" class="headerlink" title="2、使用cnpm"></a>2、使用cnpm</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install xxx</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/DongShanYuXiao/article/details/129902599">npm使用国内淘宝镜像的方法（两种）-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 镜像 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
